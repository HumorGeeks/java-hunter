# JVM 类加载机制

> 目标
>
> - 模拟实现Tomcat的webappClassLoader
> - 模拟实现Tomcat的JasperLoader热加载

## Java 代码大致流程图

<img src="https://note.youdao.com/yws/public/resource/35faf7c95e69943cdbff4642fcfd5318/xmlnote/959BC07ABE464141BB096AD41BC3708A/102280" alt="https://note.youdao.com/yws/public/resource/35faf7c95e69943cdbff4642fcfd5318/xmlnote/959BC07ABE464141BB096AD41BC3708A/102280" style="zoom: 67%;" />

类加载过程有如下几步：

**加载 >> 验证 >> 准备 >> 解析 >> 初始化 >>** 使用 >> 卸载

- 加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个**代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口
- 验证：校验字节码文件的正确性
- 准备：给类的静态变量分配内存，并赋予默认值
- 解析：将**符号引用**替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的**静态链接**过程(类加载期间完成)，**动态链接**是在程序运行期间完成的将符号引用替换为直接引用，下节课会讲到动态链接
- **初始化**：对类的静态变量初始化为指定的值，执行静态代码块

​    ![0](https://note.youdao.com/yws/public/resource/35faf7c95e69943cdbff4642fcfd5318/xmlnote/8ED5F11F99ED4C29BBBFCBB9C874F20A/102279)

类被加载到方法区中后主要包含 **运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用**等信息。

**类加载器的引用**：这个类到类加载器实例的引用

**对应class实例的引用**：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。

**注意，**主类在运行过程中如果使用到其它类，会逐步加载这些类。

jar包或war包里的类不是一次性全部加载的，是使用到时才加载

## JVM 内存模型

> Java 跨平台特性怎么做到的

![](https://gitee.com/HumorGeeks/img/raw/master/img/202111251604337.png)

> PS：线程共有：堆、方法区；线程独有：栈、本地方法栈、程序计数器

### 堆

> 存放程序运行过程中创建的对象

1. eden区
2. s0、s1
3. 老年代

### 栈

> Java 虚拟机会为每一个线程分配一块内存空间（在栈里边），这块内存空间成为栈

#### 栈桢

> Java 虚拟机会为每一个方法分配一块内存空间（在栈里边），这块内存空间成为栈桢

#### 栈桢包含哪些东西

> 局部变量表、操作数栈、动态链接、方法出口

1. 局部变量表
   1. 基本类型（存放方法内定义的局部变量）
   2. 引用类型（存放方法内定义的对象的内存地址）
2. 操作数栈（存放方法致执行过程中的操作数和结果）
3. 动态链接（存放内部方法的内存地址）
4. 方法出口（记录执行完后从主方法的哪一行开始执行）

### 程序计数器

> 记录每个线程当前执行到哪一步、每个线程独有

### 方法区

> 常量、静态变量、类元信息

### 本地方法栈

> 分配给每个本地方法执行的一片内存空间

### 垃圾回收

#### GC Root

1. 栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中 JNI 引用的对象

#### GC 方式

1. minor gc
2. full gc

#### STW 机制

> 用户线程执行过程中、某些对象引用会被释放，导致之前找的所有链路上的对象（大部分为垃圾对象）未被及时清理，没有意义

### JVM 内存参数设置

-Xss：每个线程的栈大小（默认为 1M）

-Xms：设置堆的初始可用大小，默认物理内存的1/64 

-Xmx：设置堆的最大可用大小，默认物理内存的1/4

-Xmn：新生代大小

-XX:NewRatio：默认2表示新生代占年老代的1/2，占整个堆内存的1/3。

-XX:SurvivorRatio：默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。

关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N

**-XX：MaxMetaspaceSize**： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。

**-XX：MetaspaceSize**： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的**-XX:PermSize**参数意思不一样，-**XX:PermSize**代表永久代的初始容量。

> -Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多

> 一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。

由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整

## 对象创建的主要流程

### java对象的指针压缩

### 对象内存分配

一般自定义的类加载器才能被回收

## 类字节码文件剖析

垃圾手机算法详解
