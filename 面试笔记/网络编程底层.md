#  面试-计算机网络基础

## TCP/IP体系下网络分层

- **应用层**：通过应用进程间的交互来完成特定网络应用（文件目录，文件传输，电子邮箱），比如 HTTP、FTP、Telnet、DNS、SMTP等协议
- **传输层**：向两个主机进程之间的通信提供通用的数据传输服务（报文段）
  - **TCP三次握手，建立连接**
    1. **第一次握手：** **客户端** 发送 SYN包 到 **服务器**，**客户端** 进入 `SYN_SEND` 状态，等待 **服务器** 确认；
    2. **第二次握手：** **服务器** 收到 SYN包 后，发送一个 SYN+ACK包 给 **客户端** ，服务器进入`SYN_RECV` 状态；
    3. **第三次握手：** **客户端** 收到服务器的 SYN＋ACK包 后，向 **服务器** 发送确认的 ACK包 。此包发送完毕，**客户端** 和 **服务器** 进入`ESTABLISHED` 状态，完成三次握手
  - **TCP四次握手，断开连接**
    1. 第1次挥手：**主动关闭方** 向 **被动关闭方** 发送一个 [FIN](https://so.csdn.net/so/search?q=FIN&spm=1001.2101.3001.7020)包，主动关闭方不中断传输 。
    2. 第2次挥手：**被动关闭方** 收到 FIN包 后，发送一个 ACK包 给 **主动关闭方** 。 就告诉 **主动关闭方** 已收到通知 。
    3. 第3次挥手：**被动关闭方** 又发送一个 FIN包，给 **主动关闭方**，用来关闭 **被动关闭方** 到 **主动关闭方** 的数据传送。
    4. 第4次挥手：**主动关闭方** 收到 FIN包后，发送一个 ACK包 给 **被动关闭方** ，至此，完成四次挥手。
- **网络层**：需要标识不同网络不同机器，（IP地址，IP协议）**网络和主机共同编址**，**路由选择算法为数据的传输选择最适当的路径**
- **数据链路层**：物理地址寻址（发送数据时，带上目标主机的MAC地址），数据的成帧（组装数据和目的地址等）、流量、差错控制（如果发送端 一致**没有收到确认帧** , 其**发送窗口一直不动** , 无法发送后续帧）
- **物理层**：负责在介质上正确的传送比特流

## IP协议

**IP地址**：网络部分 + 主机部分；**地址和子网掩码与**之后都一样则为**同一个子网**；才能计算发送的路由

- `A`类地址由`8`位网络标识+`24`位主机标识组成,网络有`126`个，每个网络中最大可容纳一千多万台主机（224-2），政府机构使用。
- `B`类地址由`16`位网络标识+`16`位主机标识组成,`B`类网络数量为`16382`个，每个网络中可容纳`6`万多台主机（216-2）,中大型企业
- `C`类地址由`24`位网络标识+`8`位主机标识组成,网络的数量可达`209`万左右，每个网络中允许存在`254`台主机（28-2）
- D类IP：224-239(224.0.0.0~239.255.255.255)，广播或组播
- E类IP：保留的地址

**子网掩码**决定着一个子网（独立的单个网络）内**可容纳的主机数量**，计算公式为：可容纳的主机数量=(`2`的`n`次方)`-2`，n代表0的个数

ARP协议在**同一子网广播**，每个设备**取出IP地址与自身对比**，相同，则把自己的**MAC地址**回复给对方

## TCP协议简介

### 报文头结构

- **源端口/目的端口**：数据发送方，接收方的应用进程端口号
- **32位序号**：**第一个TCP报文段中**，序号值被**系统初始化**，**之后的为该序号+字节流偏移**
- **32位确认号**：收到的TCP报文段的序号值加1，**每一个都有一个自己的和对方确认的**
- **4位头部长度**（header length）**：标识该TCP头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节**
- **6位标志位**：
  - URG标志，表示紧急指针（urgent pointer）是否有效
  - ACK标志，表示确认号是否有效。我们称**携带ACK标识的TCP报文段为确认报文段**
  - PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据
  - RST标志，表示要求对方重新建立连接，**复位报文段**
  - SYN标志，表示请求建立一个连接，**同步报文段**
  - FIN标志，表示通知对方本端要关闭连接了。**结束报文段**
- **16位窗口大小**：**告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据**，这样对方就可以控制发送数据的速度
- **16位校验和**：接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏
- **16位紧急指针**：它和序号字段的值相加表示最后一个紧急数据的下一字节的序号
- **TCP头部选项**：这块属于动态的可选择参数。主要选项如下：最大报文段长度、窗口扩大、时间戳

### TCP中的沾包问题

**缓冲区足够多的时候才发送一包数据**，因此发送发传输的数据就出现了沾包问题

**需要发送的数据大于`MSS`规定**，那么`TCP`就会对数据包进行拆

`TCP`短连接和无结构数据不需要考虑沾包问题

长连接需要考虑：每个数据包封装成**固定长度**，不够的用`0`补齐，接收方**每次按照固定大小读取**数据即可；数据之间设置边界，比如添加特殊符号

### TCP可靠性传输

- 滑动窗口：收到第一个`ACK`确认应答后，窗口向后移动，发送后续的数据，因为这个窗口不断向后滑动
- 快速重传：接收方会**持续向发送方传输相同的`ACK`应答序号**，当发送方连续三次接收到相同的应答序号时，就会对该序号的数据报进行重发
- 延迟应答：窗口越大，网络吞吐量就越大，传输效率就越高
- 捎带应答：ACK`应答可以**和接收方回应的数据报文一起返回**
- 定时器
  - 超时重传定时器：超出规定时间范围后，未收到应答信息，对数据进行重发
  - 保活定时器：如果已建立的连接**超出规定时间后还没有数据交互**，则保活定时器超时
  - 持续定时器：接收方缓冲区数据满，发送方将窗口置`0`，缓冲区数据被读取后，通知发送方可以继续传输数据，**防止该`ACK`丢失导致死锁现象出现**，发送方每隔一段时间，发送方会主动发送探测包，迫使接收端响应

## 建立连接三次握手，而关闭连接却是四次握手

> **建立连接时，ACK和SYN可以放在一个报文里来发送，关闭连接时，被动关闭方可能还有数据未传送完**
>
> **两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号**

## UDP协议简介

### 报文头结构

- **源端口/目的端口**：数据发送方，接收方的应用进程端口号
- **报文长度**：`Header+Data`的总长度
- **效验和**：检测UDP数据报在传输中是否有错

### 丢包问题

- **接收端处理数据时间过长**，导致不同包之间的数据处理间隔时间过长，造成丢包
- **单个数据包过大**，导致缓冲区快速被填满，接收端程序来不及处理造成丢包（切割数据后分批次）
- **发送端数据发送频率过快**（在程序内再实现一个缓存区）
- **网络不稳定**（自己实现重发机制）

# 面试-HTTP和HTTPS

## HTTP工作流程

- 客户端连接`WEB`服务器：**浏览器与服务器**的`HTTP/80`端口**建立一个套接字连接**。
- 发送`HTTP`请求：根据用户的`URL`，通过套接字连接向服务器**发送对应的请求报文**。
- 服务器处理请求并返回响应结果：**解析请求**、**定位资源**、**执行逻辑后将结果写到套接字**，客户端从套接字中获取结果。
- 释放`TCP`套接字连接：默认情况下，**服务器主动终止套接字连接，客户端被动关闭**

## URL结构

- scheme：表示使用的**协议类型**，例如 http、https、ftp、chrome等。
- //：协议类型与后续描述符之间的**分隔符**。
- domainName：网站域名，经**DNS解析后会得到具体服务器IP**。
- /path：请求**路径**，代表客户端请求的资源所在位置，不同层级目录之间用/区分。
- ?query1=value&query2=value：多个**请求参数**，不同的参数之间用&分割。
- \#fragment：表示所定位**资源的一个锚点**，**浏览器可根据这个锚点跳转对应的资源位置**

## DNS域名解析

顶级域（根域名服务器）+二级域（顶级域名服务器）+子域（授权域名（子域）服务器）+主机

**DNS解析过程（先递归+后迭代方式）**

- 查询**浏览器的`DNS`缓存**
- 继续查询`OS`的`hosts`文件
- **本地域名服务器**先查询**自身缓存**，未命中则**向根域名服务器**行**迭代查询**
  - 「根域名服务器」返回「**顶级域名服务器**」的地址
  - 「**本地域名服务器**」再根据地址向「**顶级域名服务器**」发起查询,「顶级域名服务器」返回负责该「域名」的「**授权域名服务器**」地
  - 「**本地域名服务器**」再根据地址向「**授权域名服务器**」发起查询, [授权域名服务器」返回「域名」的**具体`IP`地址**
  - 将`IP`返回给客户端并将「域名/`IP`映射」缓存起来,「浏览器」得到`IP`后，向其发出具体的「用户请求」

## HTTP报文结构

**请求报文字段**

- `Accept`：代表客户端支持的数据类型
- `Accept-Charset`：表示客户端支持的字符集
- `Accept-Encoding`：表示客户端支持的内容编码格式
- `Accept-Language`：表示客户端支持的语言语种
- `Authorization`：表示客户端的认证信息
- `Host`：表示客户端访问的目标资源所在的主机
- `Referer`：资源引用链，也称为防盗链，表示获取资源的请求来自哪个页面
- `If-Match`：实体标记，该值与请求的目标资源`ETag`值一致时，服务器才受理该请求。
- `If-Modified-Since`：效验客户端本地资源的时效性，如果本地的缓存资源没有超时则不处理请求。
- `If-None-Match`：和`If-Match`作用相反，该值与`ETag`值不一致时才处理请求。
- `If-Range`：`If-Match`的升级版，访问的资源`ETag`值或时间一致时，服务器处理此请求。
- `If-Unmodified-Since`：`If-None-Match`的升级版，与`If-Range`作用相反
- `Max-Forwards`：最大传输逐跳数，也就是请求允许被转发的最大次数
- `Range`：表示获取部分资源

**应答报文字段**

- `Accept-Ranges`：表示服务器是否接受按字节范围获取数据的请求。
- `Age`：表示服务器创建响应资源的时间。
- `ETag`：实体的标识，资源的匹配信息。
- `Location`：告诉客户端资源的重定向位置/（`URL`）路径。
- `Proxy-Authenticate`：将代理服务器需要的认证信息返回给客户端。
- `Retry-After`：请求失败后，告诉客户端多久后重试。
- `Server`：告知客户端目前服务端的`HTTP`服务器信息，一般为`Nginx`。
- `WWW-Authenticate`：客户端请求资源失败时，告知其目标资源所需的认证方案，如`Basic、Digest`，一般配合`401`使用。
- `status`：客户端请求后的响应状态。
- `Vary`：代理服务器的缓存管理信息

**实体首部字段**

- `Allow`：告知客户端所请求的资源支持的`HTTP`方法，如请求方法错误会以`405`状态返回。
- `Content-Encoding`：告知客户端资源（实体）数据所采用的编码方式。
- `Content-Language`：告知客户端资源所采用的自然语言，即`zh-ch、en-US`等。
- `Content-Length`：告知客户端资源的大小（字节长度）。
- `Content-MD5`：告知客户端资源的报文摘要。
- `Content-Location`：告知客户端资源所在的位置。
- `Content-Range`：告知客户端资源接受按字节区域获取的范围。
- `Content-Type`：告知客户端资源的数据类型。
- `Expires`：告知客户端资源的过期时间。
- `Last-Modified`：告知客户端资源最后一次的修改时间。

**通用报文字段**

- `Cache-Control`：控制浏览器缓存的行为，常用选项如下：
  - `max-age=N`：请求到资源后将其**缓存在本地**，有效期为`N`秒。
  - `no-cache`：**协商式缓存**，请求到资源后缓存到本地，后续每次请求资源时先与**服务器确认是否更新过**，更新则重新请求，否则从缓存中读取资源。
  - `no-store`：**禁用浏览器本地缓存**，每次从服务器上获取资源。
  - `max-age=N,must-revalidate`：请求到资源后将其缓存，有效期为`N`秒，**到期后再与服务器协商确认资源是否更新**，**未更新则延长有效期**，否则重新获取。
- `Connection`：是否开启长连接，设为`Keep-Alive`代表开启长连接。
- `Date`：`HTTP`报文的创建时间，使用格林威治标准格式。
- `Pragma`：`1.1`版本之前的历史遗留字段，为了兼容而设计的。
- `Transfer-Encoding`：指定了报文主体传输时的编码格式，如`Transfer-Encoding: chunked`。
- `Upgrade`：用于检测协议版本，是否有其他更高的版本可用。
- `Via`：追踪客户端和服务端之间的报文的传输路径，一般在使用代理服务器时必须要用的字段。
- `Warning`：告知客户端一些与缓存相关的警告信息。

**其他报文字段**

- `Cookie`：由于`HTTP`是一种无状态协议，因此通常使用`Cookie`也实现一些需要保持状态的功能，如身份`Token`、登录信息等，一般用于请求报文中。
- `Set-Cookie`：一般用于应答报文中，实**现服务器给客户端传递`Cookie`信息（值，有效期，指定域名，指定路径，是否安全连接HTTPS）**，常用属性如下：
- `Content-Disposition`：主要用于文件上传与下载时指定操作和名称
  - 上传时（`form-data`：以表单形式提交`multipart`数据）
  - 下载时：（`inline`：将文件内容直接在网页上显示；`attachment`：下载文件时弹出对话框让用户确认下载；`filename`：下载/上传时指定文件的名称）

### 请求报文

**请求行**（请求方法、资源路径以及协议版本） + **请求头**（请求报文+通用报文）+ **请求主体**（实体首部字段）

### 响应报文

**状态行**（协议版本、状态码、状态描述） + **响应头**（应答报文+通用报文） + **响应主体**（实体首部字段）

## Get和Post方法区别

- **功能不同**，`GET`用来获取数据，`POST`用于提交数据
- **传输数据的方式不同**，**安全性不同**`GET`直接在`URL`拼接参数显式传输，`POST`则是隐式传输
- **允许传输数据时的长度不同**，`GET`通常情况下受到浏览器和服务器的限制，因此可传输的参数有限，而`POST`则没有限制
- **执行效率**，GET》POST
- **支持的数据传输格式不同**：`GET`仅支持`ASCII`字符，而`POST`支持整个`ISO10646`字符集
- **浏览器缓存方面支持性**；`GET`请求的资源**默认会被浏览器缓存**；`POST`请求的资源默认情况下不会缓存

## 长连接

`HTTP/1.0`中**默认关闭**，需要手动在请求头中添加`Connection: Keep-Alive`才可开启，`HTTP/1.1`**默认开启**，可以手动添加`Connection: close`关闭

## 队头阻塞

**所有的请求**会被放入到一个**队列中依次交由服务器处理**，前面的请求任务执行时间过长

并发连接（根据浏览器内核不通默认值不同）+ 域名分片（多准备几个域名，然后域名配置的`IP`映射都指向同一台服务器）

## HTTP代理技术

**正向**：客户端发送请求时需要指定目标服务端

**反向**：当用**客户端**根据域名解析`IP`访问时，其实解析得到的是**反向代理服务器所在的机器`IP`**，当客户端请求发送到反向代理服务器时，代理服务器会将请求分发到具体的“服务端机器”上处理，由代理服务器将结果响应给客户端

**隧道代理**：`HTTPS`需要认证，但代理显然不可能有网站的私钥证书，最终就会导致客户端和代理之间的`TLS`无法建立，隧道代理在其中只负责将浏览器和服务器之间通信的数据原样透传

## 对称加密和非对称加密

**对称加密**：加密通信的双方加/解密的方式都是相同（一对多，单个破解全部破解）

**非对称加密**：用**公钥**加密的数据，只有用对应的**私钥**才能解密

## HTTPS工作流程

- 先向服务端**请求公钥**，与服务端`443`端口建立连接
- 将**数字证书**（申请信息、服务器公钥、数字签名【单向的哈希算法加密为**信息摘要**；通过自己的密钥对“信息摘要”进行再次加密】）返回给客户端
- 确认证书合法后（通过`CA`机构的公钥**解密证书中的「数字签名」**；客户端会使用与`CA`机构相同的`Hash`算法生成摘要进行比较），会先生成一个对称密钥，然后通过证书中的公钥对其加密，并发给服务端
- 服务端收到公钥加密后的对称密钥后，通过自己的私钥对其解密
- 最终客户端、服务端**都拥有了一把对称密钥**，接下来则通过对称密钥传输数据

## TLS四次握手过程

**（非对称加密进行验证+对称加密进行传输）**

- **第一次握手**：**SSL/TLS版本**（确定SSL/TLS版本）+ **客户端生成的随机数**（**Client Random** 用于生成会话密钥）+ **客户端支持的密码套件列表**（如RSA算法）
- **第二次握手**
  - 服务端响应的`Server Hello`信息中，确认自己是否支持`TLS`版本，**不支持断开**；发送**TLS版本 + 密码套件中选择一套**+**服务端随机数**（**server-random**用于生成回话秘钥）
  - **将自己的数字证书**（公钥+持有者+有效时间+认证机构+其他）发给客户端；**私钥存储在服务端本地**；**客户端验证有效（）则继续**，如果证书**无效则会发出警告信息并中断`TCP`连接**
  - 通过一条`Server Key Exchange`消息，将**密钥交换算法需要用到的数据/参数携带上去**
  - **服务端要求客户端上报证书**，这一步是可选的，因为`HTTPS`可以选择双向验证，对于安全性要求高的场景会用到，默认是不发送这条信息
  - 服务端**最后会发送一条`Server Hello Done`的信息**
- **第三次握手**
  - `Client Key Exchange`这条信息就是**客户端**将**预主密钥**（**premaster secret**：公钥+算法+参数）**通过公钥加密**传给服务端；**服务端收到该消息后**，会**通过自己的私钥解密，然后得到第三个随机数**，到此刻为止，客户端和服务端之间都各自拥有了三个随机数：**client-random、server-random、premaster secret**
  - **Change Cipher Spec** **通知服务端密钥已经计算出来**了，**切换到对称加密模式**
  - **Encrypted Handshake Message**服务端**接受后**，也能够通过计算出的密钥解开，即代表前面协商计算出的**对称密钥没有问题**
- **第四次握手**
  - **Change Cipher Spec**：通知客户端：我已计算出对称密钥，后续通信采用加密模式
  - 服务端的**第一条加密信息**，用于**测试客户端计算出的密钥是否可以解开加密数据**

# 面试-Nginx

- **请求分发**

  - 监听Http请求端口
  - 根据配置的**location**规则定位**upstream**配置信息
  - 根据权重比分发请求

- **动静分离（静态资源文件单独配置访问规则，减少服务器并发数）**

- **资源压缩**（访问的文件大小变小好几倍）

- **Nginx缓冲区**（解决客户端→`Nginx`、`Nginx`→服务端速度不匹配的问题）【请求截断问题】

  - proxy_buffering：是否启用缓冲机制
  - client_body_buffer_size：设置缓冲客户端请求数据的内存大小
  - roxy_buffers：为每个请求/连接设置缓冲区的数量和大小
  - proxy_buffer_size：设置用于存储响应头的缓冲区大小
  - proxy_temp_path：当内存缓冲区存满时，可以将数据临时存放到磁盘
  - proxy_busy_buffers_size：在后端数据没有完全接收完成时，Nginx可以将busy状态的缓冲返回给客户端

- **Nginx缓存机制**

  - proxy_cache_path：代理缓存的路径
  - proxy_cache：开启或关闭代理缓存
  - proxy_cache_valid：缓存生效的状态码与过期时间
  - proxy_cache_min_uses：设置资源被请求多少次后被缓存
  - proxy_cache_use_stale：当后端出现异常时，是否允许Nginx返回缓存作为响应
  - proxy_cache_methods：设置对于那些HTTP方法开启缓存
  - **缓存清理**（ngx_cache_purge：第三方）

- **IP黑白名单**

  - allow、deny配置项

- **跨域**（**同源策略**）

- **防盗链机制**（**指外部网站引入当前网站的资源对外展示**）

- **配置SSL证书切换HTTP为HTTPS**

- **高可用**

  Keepalived+重启脚本+双机热备搭建

  ![image-20230810162544588](网络编程底层.assets/20230724024159.pngorigin_url=file%3A%2F%2FH%3A%2Finterview%2F面试笔记%2F面试-网络编程.assets%2Fimage-20230810162544588.png%3FlastModify%3D1709458612&pos_id=n5RAFjiD)

  ![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

- **性能优化**

  - 打开长连接配置
  - 零拷贝读取机制（**硬件-->内核-->【用户空间-->程序空间】-->程序内核空间-->网络套接字**），避免中间过程
  - 开启**无延迟**或**多包并发**（实时交互性高，每个数据包立即发出；高吞吐尽量进行多包拼接）
  - 调整**Worker工作进程**（自动根据CPU核心数调整Worker进程数量+每个工作进程能够打开的文件句柄数（不能超出内核限制，最多建议`3.8W`））
  - **开启epool模型增加并发连接数**

# 面试-负载均衡

## 静态调度算法

- 轮询（依次**均摊**分发（无法发挥高配置服务器），**弹性伸缩**；无法保证**同一客户端的请求都是由同一节点处理**的；`session`记录状态时，无法确保其一致性）

- 随机（**不均摊分发**；）

- 加权

  - 普通加权轮询（**求和所有的权重值**，随机生成一个总权重之内的索引；**逐次往后，小于停止，大于减去当前权重，继续往后**）【集群变为单点服务，**每个机器负责一定范围**】

  - 平滑加权轮询（**动态权重** = **上一次最大权重减去总权重** + 静态权重），取最大权重减去总权重最小的

    ![image-20230810172340583](网络编程底层.assets/20230724024159.pngorigin_url=file%3A%2F%2FH%3A%2Finterview%2F面试笔记%2F面试-网络编程.assets%2Fimage-20230810172340583.png%3FlastModify%3D1709458612&pos_id=A3hgLSP6)

    ![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

    

- 一致性哈希（【**哈希环，这个圆总共由`2^32`个点组成**；【服务器`IP`、客户端`IP`或缓存的`Key`】来计算】**确保同一客户端的所有请求都分发在同一台服务器处理**）**TreeMap**

  - 导致问题：映射偏移（**过分集中**）导致连锁宕机
  - 优化：
    - 先根据指定的数量，**映射对应的虚拟节点数量**在哈希环
    - 通过**计算客户端哈希值**，然后在哈希环上**取得大于该值的节点**
    - 如果哈希环中没有大于客户端哈希值的节点，发到整个`Map`上的**第一台服务器**

## 动态调度算法

- 最小活跃数【**一台节点存在故障**，导致它**自身处理的请求数比较少**，那么它**会遭受最大的访问压力**】
  - 找出**活跃数最小的节点**，**只有一个**，那么则直接返回
  - 多个**优先选取权重值最大**（随机选取一个）的实例
- 最优响应
  - 使用**随机数**+**线程休眠**的方式简单模拟了一下节点的不同的响应速度，然后在**算法实现类中**，利用`CompletableFuture`分别**对每一个节点都创建了对应的`Ping`任务**，然后**同时执行**，又通过`thenAccept()`**回调方法监听了执行结果，谁最先响应，则取其作为处理本次请求的节点**

# 面试-接入层高并发设计

## **DNS域名解析**

（Rate**权重分配**、**最少连接数**分配、甚至可以按照**客户端网络的运营商、客户端所在地区**等方式进行解析分配）

- **缺陷**：**无健康监测机制** + **无法区别服务器的硬件配置**

## **CDN内容分发**

（**智能`DNS`解析技术**【请求的时候映射为**cdn.xxx.com**；CDN服务器**选出来最近的返回**】）

- **加快**用户静态资源的访问速度
- **分担**系统`50%`以上的访问流量
- **节省系统源站的带宽消耗**
- 大部分攻击请求会被`CDN`节点阻挡

## **LVS负载均衡**

**优势**

- 直接位于`Linux`内核中工作，因此`LVS`的性能一般是`Nginx`的十倍以上
- 将许多**低性能的服务器**组合在一起形成一个**高性能的超级服务器群**
- 四种工作模式以及十二种调度算法
- 健全的**节点健康监测**机制和**拓展性**

**工作原理**

- **客户端**通过访问`VIP`**发送请求报文**，调度器收到后会将其发往内核空间
- 内核中的`PREROUTING`链会先收到请求，**确认是发往自己的请求后**会转给`INPUT`链
- 将**用户请求和`VIP`列表进行匹配**，匹配成功后会**修改请求报文中的目的地址及端口**，然后将新的报文发给`POSTROUTING`链
- `POSTROUTING`链收到报文后，发现更改后的报文中目标地址正好是自己配置的后端服务器`RS`地址，那此时就**会通过选路**，最终将数据报文发送给后端服务器

**工作模式**

- **网络地址转换模式**（**LVS和后端位于同一网段**；**双向流量都需要经过LVS**）
  - 客户端**请求VIP**
  - LVS将客户端请求报文中的**目标地址改为后端一台具体的地址**
  - 将请求处理完成后，会将**响应结果组装成应答报文返回**给LVS
  - LVS修改**响应结果中目标地址**
- **直接路由模式**（**LVS**与**后端的服务绑定一个IP**；**双向流量变为入流量**）
  - 客户端**请求VIP**
  - LVS会将报文中的**目标MAC地址**改变为**某台RS的MAC地址**
  - RS验证IP和MAC，根据请求报文中源地址，直接返回
- **IP隧道模式**（**LVS**与**后端的服务绑定一个IP**；**VIP、DIP、RIP必须全部要为公网IP**）
  - 客户端**请求VIP**
  - 封装为：源地址 + 虚拟地址 + 响应服务器地址
  - 响应服务器解析数据包，响应请求，**直接返回给客户端**
- **双向网络地址转换模式**（解决之前需要处于同一个网段的问题；跨VLAN，机房，网络）
  - 客户端会先发送请求报文（**客户端IP + VIP**）到LVS
  - LVS收到客户端的报文后改写（自身DIP + RIP）
  - RS接收到请求后会进行处理，处理完成之后会将应答报文返回给LVS服务器
  - LVS会将应答报文中的源IP改为`VIP`，目标IP为CIP，从而将数据响应给客户端

**直接路由模式是性能最好**的，也是正常情况下使用最为频繁的工作模式，同时也是`LVS`**默认的工作模式**

## **LVS调度算法**

### 静态调度

- 轮询算法
- 加权轮询算法
- 源地址哈希算法（解决`session`不一致问题）
- 目标地址哈希算法（一般用于有缓存场景）

### 动态调度

- 最小活跃连接数算法（`LC`）
- 加权最小连接数算法（`WLC`）
- 最短延迟算法（`SED`）
- 最少队列算法（`NQ`）【**实现了一个活跃连接数为`0`的判断**】
- 局部最少连接数算法（`LBLC`）【先根据目标地址找出**最近使用的一个服务器**，不可用找出集群**连接数最小节点**】
- 带复制的局部最少连接数算法（`LBLCR`）【会维护一个**目的地址与一组服务器的映射表**，而`LBLC`算法中只会维护目的地址与一个服务器的映射关系】
- 加权故障转移算法（`FO`）【负载低 + 权重高】
- 加权活动连接数算法（`OVF`）【权重高 + 连接数少 + 负载低】

## Nginx与Gateway网关高可用

### 为Nginx配置从机后的接入层架构

![配置从机](网络编程底层.assets/20230724024159.pngorigin_url=file%3A%2F%2FH%3A%2Finterview%2F面试笔记%2F面试-网络编程.assets%2Faf2bd9a3388b42cdb1abecb23195c25dtplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp%3FlastModify%3D1709458612&pos_id=DangwK6w)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

### 不为Nginx配置从机后的接入层架构

![不配从机](网络编程底层.assets/20230724024159.pngorigin_url=file%3A%2F%2FH%3A%2Finterview%2F面试笔记%2F面试-网络编程.assets%2F2342a64b131a4a1886a97a25a733336ctplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp%3FlastModify%3D1709458612&pos_id=kETfXjPv)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

### Gateway网关高可用

![接入层架构](网络编程底层.assets/20230724024159.pngorigin_url=file%3A%2F%2FH%3A%2Finterview%2F面试笔记%2F面试-网络编程.assets%2F028c73dda628449f9862b4140ba95f21tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp%3FlastModify%3D1709458612&pos_id=7L5by0Wm)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

## **百亿单日流量**平台常用的数据指标

**PV**：平台页面被浏览/点击的总次数，每次访问或刷新都会计入一次PV。 **UV**：一天内访问平台的总用户数（以客户端cookie作为计算依据）。 **IP**：一天内访问平台的独立IP总数（以客户端IP地址作为计算依据）。 **QPS**：平台一秒内接收到的请求总数（**峰值QPS = (单日流量 \* 80%) / (60 \* 60 \* 24 \* 20%**)【`80%`的访问集中在`20%`的时间里】） **TPS**：平台一秒内接收到的事务总数【**客户端请求、服务端处理、服务端响应**】。 **RPS**：平台每秒能够处理的请求总数（吞吐量）。 **RT**：执行一个请求从访问到响应的总体时间。 **最大并发数**：平台能够在同一时刻同时处理的最大请求数。 **单日流量**：一天内平台收到的请求总数

## **百亿单日流量**参数计算

- **计算 QPS**————————————–462963
- **计算流量最大并发数**（`QPS` / (一秒 / 平均响应时间)）————-231481.5
- **计算单机最大并发数**（节点最大并发数 * (一秒 / 请求处理时间)）———————————————————————————–4000
- **计算节点数量**
  - **节点数量**（流量最大并发数 / 节点最大并发数）
  - **节点数量**（峰值`QPS` / 单机`QPS`上限）

## **百亿单日流量**逐层设计

### 接入层

- **LVS一主一备**（LVS-DR的最大连接数上限大概在30-50W）但为了容错需要再搭建一个**容灾集群**，因此LVS共计**四台**。
- **Nginx**（单节点并发连接数5W左右，线上做**反向代理实际3W**左右）231481.5/30000≈8，Nginx大概需要8台。
- Gateway网关由于不做具体的业务处理，**默认最大连接数在1W**左右231481.5/10000≈24，Gateway网关大概需要24台左右。

### 系统服务层

- SpringBoot内嵌的Tomcat：默认最大连接数也是1W，但由于要处理业务请求，因此**线上能达到2000**左右已算极致231481.5/2000≈116，Tomcat大概需要116台左右。
- 还要考虑到**微服务的生态圈，服务不可能单独部署，注册中心、服务保护、系统监控、定时调度、授权中心、CI/CD自动化等**.....
- 因此系统服务层的完整构建，至少需要大概180+台左右的实例。

### 中间件层

- 缓存中间件Redis，线上单机性能大概在5W左右的最大连接数。231481.5/50000≈5，但由于缓存的特殊性，至少需部署20台以上。
- 分库分表中间件：8台左右。
- ELK分布式日志收集10台左右。
- Kafka、RabbitMQ消息中间件共计30台左右。
- ElasticSearch搜索中间件共计30台左右。

### 存储层

- Mongodb大概需要30台左右。
- **MySQL与Tomcat的数量大致对应**，100台左右（有些库需要水平集群）。
- 大数据CDH全家桶50台以上。
- FastDFS分布式文件存储共计20台左右

# 面试-浏览器输入URL发生了什么

- 用户在地址栏输入内容，**浏览器**判断后**生成相应的URL**并传给网络进程。
- **网络进程**先**查询本地缓存**，没有则解析URL并向DNS发送请求，得到IP。
- 网络进程先与目标服务器进行TCP、TLS多次握手，**建立TCP、TLS安全连接**。
- 紧接着**组装请求报文**，并由各个分层对数据进行封装，最终转为0、1格式。
- 基于建立好的连接，**利用物理介质传输数据**，通过路由器控制数据的传输方向。
- 请求会先**去到CDN查询是否有缓存的内容**，如果没有则继续向下请求。
- 请求**来到LVS后被转发到Nginx**，再由**Nginx转发到Gateway网关**。
- Gateway网关根据配置好的API分发规则，将请求分发到**具体服务**。
- 紧接着再**从Nacos注册中心**内，查询出该服务的具体服务实例IP。
- 请求来到具体的**服务器**后，先通过端口号找到具体的**WEB服务进程Tomcat**。
- Tomcat基于**SpringMVC**的工作流程为请求**定位到具体的Java后端方法**。
- 线程执行Java方法时，先去**Redis中查询是否有数据**，没有则查询**MySQL**。
- 查询DB前先通过**MyBatis生成SQL语句**，然后再通过DB连接执行SQL。
- 请求根据已**配置的数据源地址，来到MySQL并执行SQL语**句，从而获得数据。
- 经过**报文组装、数据封装、请求转发**等操作，向客户端响应数据(原路返回)。
- 应答报文经**物理介质传输后**，最终抵达客户端网络进程(可能会将数据加入缓存)。
- 网络进程将数据交给**浏览器之后，根据情况准备做TCP四次挥手，断开连接**。
- 浏览器**创建渲染子进程，然后根据数据生成渲染树，最后绘制并显示页面**。

# 面试-IO模型

## **基本概念**

**磁盘IO**，**网络IO**；

**用户态**（调用OS内核提供的函数，cpu允许抢占）；

**内核态**（**直接访问**操作系统内核**数据结构**和**程序**；**cpu不允许被抢占**）；

**内核态用户态切换**（**用户态的程序**调用某个**内核提供的函数时**；**用户态不具备权限**）

## 普通IO工作流程

常听的`BIO、NIO、AIO`之间的区别，就在于这**准备阶段**（数据**从网络网卡或本地存储器读取到内核**）和**复制阶段**（**内核缓冲区中的数据拷贝至用户态的进程缓冲区**）中的操作是同步还是异步的，是阻塞还是非阻塞的**

- **网卡**上或**本地存储设备**中准备数据
- 调用`read()`函数，由**内核**将网络/本地数据读取到**内核缓冲区**中
- 向`CPU`发送一个**中断信号**，通知`CPU`对数据进行后续处理
- `CPU`将内核中的数据**写入**到对应的**程序缓冲区**或**网络`Socket`接收缓冲区**
- **应用程序**开始对数据开始实际的处理

## 五种IO模型浅析

### 同步阻塞BIO

- **所有阶段程序都是阻塞**
- 支持**并发**请求，通常情况下会**采用“请求：线程”`1:1`的模型**
- **Tomcat**中线程池声明了**核心线程数**以及**最大线程数**；超出客户端的请求**加入请求队列**中等待

![image-20230813133050818](网络编程底层.assets/20230724024159.pngorigin_url=file%3A%2F%2FH%3A%2Finterview%2F面试笔记%2F面试-网络编程.assets%2Fimage-20230813133050818.png%3FlastModify%3D1709458612&pos_id=xWstx0gb)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

### 同步非阻塞NIO

**非阻塞过程**：应用程序中发起`IO`调用后，**内核并不阻塞read（）当前线程**，而是**立马返回一个“数据未就绪**”的信息给应用程序，**应用程序一直反复轮询去问内核数据是否准备好**【非阻塞】

**缺陷**：轮询查看数据是否准备就绪，造成`CPU`开销较大

![image-20230813133558627](网络编程底层.assets/20230724024159.pngorigin_url=file%3A%2F%2FH%3A%2Finterview%2F面试笔记%2F面试-网络编程.assets%2Fimage-20230813133558627.png%3FlastModify%3D1709458612&pos_id=MaNcW2Zz)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

### 多路复用模型

![image-20230813133928152](网络编程底层.assets/20230724024159.pngorigin_url=file%3A%2F%2FH%3A%2Finterview%2F面试笔记%2F面试-网络编程.assets%2Fimage-20230813133928152.png%3FlastModify%3D1709458612&pos_id=gQGUK6JS)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

出现一个`IO`操作时，会通过**调用内核提供的多路复用函数**，将当前**连接注册到监听器上**，当**监听器发现该连接的数据准备就绪后**，会**返回一个可读条件给用户进程**，然后用**户进程拷贝内核准备好的数据**进行处理

### 信号驱动模型

- 用户进程中首先会创建一个`SIGIO`**信号处理程序**
- 内核中的数据准备好之后，**内核会生成一个`Sigio`信号**，通知对应的用户进程数据**已准备就绪**
- 用户进程**触发一个`recvfrom`的系统调用**，从**内核中**将数据拷贝出来进行处理

![image-20230813134315692](网络编程底层.assets/20230724024159.pngorigin_url=file%3A%2F%2FH%3A%2Finterview%2F面试笔记%2F面试-网络编程.assets%2Fimage-20230813134315692.png%3FlastModify%3D1709458612&pos_id=sydPsnkK)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

### 异步非阻塞AIO

- 调用`aio_read、sigaction`函数，然后**用户进程**中会创建出一个**信号处理程序**
- **数据写入到内核、且从内核拷贝到用户缓冲区后**，内核会通知对应的用户进程对数据进行处理

### java实现

#### **ServerSocket**

- **服务端**启动后会执行`accept()`方法**等待客户端连接**到来
- **客户端**启动后会通过`IP`及端口，与服务端通过`Socket`套接字**建立连接**
- 双方**各自从套接字中获取输入/输出流，并通过流对象发送/接收消息**

```
// BIO服务端
public class BioServer {
    public static void main(String[] args) throws IOException {
        System.out.println(">>>>>>>...BIO服务端启动...>>>>>>>>");
        // 1.定义一个ServerSocket服务端对象，并为其绑定端口号
        ServerSocket server = new ServerSocket(8888);
        // 2.监听客户端Socket连接
        Socket socket = server.accept();
        // 3.从套接字中得到字节输入流并封装成输入流对象
        InputStream inputStream = socket.getInputStream();
        BufferedReader readBuffer =
                new BufferedReader(new InputStreamReader(inputStream));
        // 4.从Buffer中读取信息，如果读到信息则输出
        String msg;
        while ((msg = readBuffer.readLine()) != null) {
            System.out.println("收到信息：" + msg);
        }
        // 5.从套接字中获取字节输出流并封装成输出对象
        OutputStream outputStream = socket.getOutputStream();
        PrintStream printStream = new PrintStream(outputStream);
        // 6.通过输出对象往服务端传递信息
        printStream.println("Hi！我是竹子~");
        // 7.发送后清空输出流中的信息
        printStream.flush();
        // 8.使用完成后关闭流对象与套接字
        outputStream.close();
        inputStream.close();
        socket.close();
        inputStream.close();
        outputStream.close();
        socket.close();
        server.close();
    }
}

// BIO客户端
public class BioClient {
    public static void main(String[] args) throws IOException {
        System.out.println(">>>>>>>...BIO客户端启动...>>>>>>>>");
        // 1.创建Socket并根据IP地址与端口连接服务端
        Socket socket = new Socket("127.0.0.1", 8888);
        // 2.从Socket对象中获取一个字节输出流并封装成输出对象
        OutputStream outputStream = socket.getOutputStream();
        PrintStream printStream = new PrintStream(outputStream);
        // 3.通过输出对象往服务端传递信息
        printStream.println("Hello！我是熊猫~");
        // 4.通过下述方法告诉服务端已经完成发送，接下来只接收消息
        socket.shutdownOutput();
        // 5.从套接字中获取字节输入流并封装成输入对象
        InputStream inputStream = socket.getInputStream();
        BufferedReader readBuffer =
                new BufferedReader(new InputStreamReader(inputStream));
        // 6.通过输入对象从Buffer读取信息
        String msg;
        while ((msg = readBuffer.readLine()) != null) {
            System.out.println("收到信息：" + msg);
        }
        // 7.发送后清空输出流中的信息
        printStream.flush();
        // 8.使用完成后关闭流对象与套接字
        outputStream.close();
        inputStream.close();
        socket.close();
    }
}
```

#### NIO

**Buffer缓冲区**（**pasition**：当前操作索引位置；**capacity**：表示当前缓冲区的容量大小；**limit**：表示当前可允许操作的最大元素位置）

**使用步骤**

- 先**创建**对应类型的**缓冲区**
- 通过**put这类方法**往缓冲区中写入数据
- 调用flip()方法将缓冲区**转换为读模式**
- 通过get这类方法从缓冲区中**读取数据**
- 调用clear()、compact()方法**清空缓冲区数据**

**本地直接内存缓冲区（手动管理，性能高）与堆内存缓冲区（GC管理， 性能低）**

**Channel通道**(双向通道)

**操作方法**

- 管理类：如**打开通道**、连接远程地址、**绑定地址**、**注册选择器**、关闭通道等。
- 操作类：读取/写入数据、批量读取/写入、自定义读取/写入等。【**抽象方法，自身未定义**】
- 查询类：**检查是否打开连接**、**是否建立了连接**、**是否正在连接**等

**Selector选择器**

**监控多个`Channel`通道**，并能够**检测**出那些通道中的**数据已经准备就绪（可以支持读取/写入）**

**使用**

先将对应的通道**注册到选择器**上，然后再调用选择器的**`select`方法去监听注册的所有通道**

- 读取就绪事件，通道内的数据已就绪**可被读取**
- 写入就绪事件，一个通道正在**等待数据写入**
- 连接就绪事件，通道**已成功连接到服务端**
- 接收就绪事件，**服务端通道已准备好接收新的连接**

`Buffer`负责存取数据，`Channel`负责传输数据，而`Selector`则会决定操作那个通道中的数据

```
// ----NIO服务端实现--------
public class NioServer {
    public static void main(String[] args) throws Exception {
        System.out.println(">>>>>>>...NIO服务端启动...>>>>>>>>");
        // 1.创建服务端通道、选择器与字节缓冲区
        ServerSocketChannel ssc = ServerSocketChannel.open();
        Selector selector = Selector.open();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        // 2.为服务端绑定IP地址+端口
        ssc.bind(new InetSocketAddress("127.0.0.1",8888));
        // 3.将服务端设置为非阻塞模式，同时绑定接收事件注册到选择器
        ssc.configureBlocking(false);
        ssc.register(selector, SelectionKey.OP_ACCEPT);
        // 4.通过选择器轮询所有已就绪的通道
        while (selector.select() > 0){
            // 5.获取当前选择器上注册的通道中所有已经就绪的事件
            Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();
            // 6.遍历得到的所有事件，并根据事件类型进行处理
            while (iterator.hasNext()){
                SelectionKey next = iterator.next();
                // 7.如果是接收事件就绪，那则获取对应的客户端连接
                if (next.isAcceptable()){
                    SocketChannel channel = ssc.accept();
                    // 8.将获取到的客户端连接置为非阻塞模式，绑定事件并注册到选择器上
                    channel.configureBlocking(false);
                    int event = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
                    channel.register(selector,event);
                    System.out.println("客户端连接：" + channel.getRemoteAddress());
                }
                // 9.如果是读取事件就绪，则先获取对应的通道连接
                else if(next.isReadable()){
                    SocketChannel channel = (SocketChannel)next.channel();
                    // 10.然后从对应的通道中，将数据读取到缓冲区并输出
                    int len = -1;
                    while ((len = channel.read(buffer)) > 0){
                        buffer.flip();
                        System.out.println("收到信息：" +
                                new String(buffer.array(),0,buffer.remaining()));
                    }
                    buffer.clear();
                }
            }
            // 11.将已经处理后的事件从选择器上移除（选择器不会自动移除）
            iterator.remove();
        }
    }
}

// ----NIO客户端实现--------
public class NioClient {
    public static void main(String[] args) throws Exception {
        System.out.println(">>>>>>>...NIO客户端启动...>>>>>>>>");
        // 1.创建一个TCP类型的通道并指定地址建立连接
        SocketChannel channel = SocketChannel.open(
                new InetSocketAddress("127.0.0.1",8888));
        // 2.将通道置为非阻塞模式
        channel.configureBlocking(false);
        // 3.创建字节缓冲区，并写入要传输的消息数据
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        String msg = "我是熊猫！";
        buffer.put(msg.getBytes());
        // 4.将缓冲区切换为读取模式
        buffer.flip();
        // 5.将带有数据的缓冲区写入通道，利用通道传输数据
        channel.write(buffer);
        // 6.传输完成后情况缓冲区、关闭通道
        buffer.clear();
        channel.close();
    }
}
```

#### AIO

要接收一个客户端的数据时，**操作系统**会先将通道中**可读的数据**先传入`read()`**回调方法指定的缓冲区中**，然后再**主动通知Java程序**

**异步通道分组**

创建了一个`group`**分组**并**绑定了一个线程池**，然后在**创建服务端通道**将其**分配到了`group`这个分组中**，那此时连接`serverChannel`的**所有客户端通道，都会共享`servicePool`这个线程池的线程资源**。这个线程池中的线程，则负责**类似于`NIO`中`Selector`的工作**

**异步回调处理**

`CompletionHandler`接口中主要存在`completed()、failed()`两个方法，分别**对应`IO`数据处理成功、失败的回调**工作

## 【待最后补充】内核Select、Poll、Epoll多路复用函数

# 面试-Netty

## 基本概念

**EventLoopGroup**：理解成之前的`Selector`选择器，但结合了线程池

**ServerBootstrap**/**Bootstrap**：类似于之前的ServerSocketChannel/SocketChannel

**childHandler**：过滤器

## 通信基本过程

- 创建两个`EventLoopGroup`**事件组**，然后创建一个`ServerBootstrap`**服务端**；创建的两个事件组`boss、worker`**绑定在服务端**上，并**指定服务端通道为`NIO`类型**
- 在`server`上**添加处理器**（连接到来时执行【添加更多的处理器】；处理器**不会立马执行**），对新到来的`Socket`连接进行处理
- 为创建好的**服务端绑定`IP`及端口号**，调用`sync()`意思是**阻塞至绑定成功为止**
- 再创建一个`EventLoopGroup`**事件组**，并创建一个`Bootstrap`**客户端**；将**事件组绑定在客户端**上，**指定客户端通道**为`NIO`类型，**添加处理器**
- 与**前面服务端绑定的地址建立连接**，由于默认是异步的，也要调用`sync()`阻塞
- 客户端将数据**写入到通道准备发送**，首先会先经过添加好的编码处理器，将**数据的格式设为`UTF-8`**
- 服务器收到数据后，会先**经过解码处理器**，然后再去到**入栈处理**，执行对应的`Read()`方法逻辑
- 客户端完成数据发送后，**先关闭通道**，再优雅**关闭创建好的事件组**
- 服务端工作完成后，**先关闭通道再停止事件组**

## 核心组件

### 启动器

ServerBootstrap、Bootstrap

### **事件组**

EventLoop【事件循环；NIO`中的`Selector】；EventLoopGroup【***异步的服务端通道***】；**拥有`JDK`线程池中所有提供的方法，同时也应该会支持执行异步任务、定时任务的功能**

- EventLoopGroup描述了Netty程序运行的线程模型，它的功能并不多，主要用来**创建EventLoop**和**优雅停机**。
- EventLoop才是**真正处理IO事件**和系统任务的角色，它干的活是一个死循环：**等待IO事件**、**处理IO事件**、**处理系统/定时任务**、**再等待IO事件**

### 增强版通道（ChannelFuture）

- **支持异步回调处理结果**
- **ChannelFuture**的**addListener**方法可以使**发起连接、建立连接、发送数据、接收数据、关闭连接**等一系列操作**都为异步**，**提高并发性能**

#### **ChannelFuture，Netty-Future,JDK-Future的关系**

**JDK-Future**：伪异步（**获取**一个异步任务的**执行结果**，此时只能**调用`get()`方法**；该方法为**阻塞方法**）

**Netty-Future**：（**非阻塞获取结果**：getNow()；**异常检测机制**：异步任务**执行出错**时，可以通过`cause()`方法处理异常；主线程**创建任务后永远不会阻塞**,通过`addLinstener()`方法**添加异步执行后的回调逻辑**；**设置异步任务的执行状态**）

### 通道处理器

- **入站处理器**（客户端消息来到触发）

  ```
  // 会在当前Channel通道注册到选择器时触发（与EventLoop绑定时触发）
  public void channelRegistered(ChannelHandlerContext ctx) ...
  // 会在选择器移除当前Channel通道时触发（与EventLoop解除绑定时触发）
  public void channelUnregistered(ChannelHandlerContext ctx) ...
  // 会在通道准备就绪后触发（Pipeline处理器添加完成、绑定EventLoop后触发）
  public void channelActive(ChannelHandlerContext ctx) ...
  // 会在通道关闭时触发
  public void channelInactive(ChannelHandlerContext ctx) ...
  // 会在收到客户端数据时触发（每当有数据时都会调用该方法，表示有数据可读）
  public void channelRead(ChannelHandlerContext ctx, Object msg) ...
  // 会在一次数据读取完成后触发
  public void channelReadComplete(ChannelHandlerContext ctx) ...
  // 当通道上的某个事件被触发时，这个方法会被调用
  public void userEventTriggered(ChannelHandlerContext ctx, Object evt) ...
  // 当通道的可写状态发生改变时被调用（一般在发送缓冲区超出限制时调用）
  public void channelWritabilityChanged(ChannelHandlerContext ctx) ...
  // 当通道在读取过程中抛出异常时，当前方法会被触发调用
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) ...
  ```

- **出站处理器**（服务端返回数据触发）

  ```
  // 当通道调用bind()方法时触发（当Channel绑定端口地址时被调用，一般用于客户端通道）
  public void bind(...) ...
  // 当通道调用connect()方法，连接到远程节点/服务端时触发（一般也用于客户端通道）
  public void connect(...) ...
  // 当客户端通道调用disconnect()方法，与服务端断开连接时触发
  public void disconnect(...) ...
  // 当客户端通道调用close()方法，关闭连接时触发
  public void close(...) ...
  // 当通道与EventLoop解除绑定时触发
  public void deregister(...) ...
  // 当通道中读取多次数据时被调用触发
  public void read(...) ...
  // 当通道中写入数据时触发
  public void write(...) ...
  // 当通道中的数据被Flush给对端节点时调用
  public void flush(...) ...
  ```

- **Pipeline处理器链表**

  **双向链表**：**接收客户端的数据时**，Head->Tail;**返回客户端的数据时**，Tail->Head;

- **自定义入站处理器**（继承ChannelInboundHandlerAdapter，重写channelRead方法）

  ```
  // 自定义的入站处理器
  public class ZhuziHandler extends ChannelInboundHandlerAdapter {
      public ZhuziHandler() {
          super();
      }
  
      @Override
      public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
          // 在这里面编写处理入站msg的核心代码.....
          // （如果要自定义msg的处理逻辑，请记住去掉下面这行代码）
          super.channelRead(ctx, msg);
      }
  }
  ```

- **自定义出站处理器**（**继承**ChannelOutboundHandlerAdapter，**重写**write方法）

### 缓冲区（ByteBuf）

**类型**

- **堆内存**：GC管理，**分配性能高**，**读写效率低**
- **本地内存**：**读写效率高**，**分配效率低**

**缓冲区基于NIO的增强**

- **缓冲区池化**（避免【重复创建和销毁】**OOM问题**）
- **动态扩容**（**避免类似NIO的手动反转指针**（采用读写两个指针）；**自动扩充容量**（分配**初始容量**，创建对应**缓冲区**，在**最大容量允许范围**内自动扩容））
- **读写API**（**避免NIO不同类型数据需要不同的子类实现**）
  - **大小端写入**：优先高位和优先低位写入（默认情况下，网络通信会采用大端写入的模式）
  - **readXXX**()：读取后，内部的读取指针随之移动，读不到之前的数据（使用mark**标记一下读取指针**，此时再通过reset方法，**使读取指针恢复到前面的标记位置**；然后再使用read方法读取数据）
  - **getXXX()：**读取数据后，不会改变`ByteBuf`内部的读取指针
- **内存回收**（引用计数法，**为0的时候变为外部不可访问**；使用完一个`ByteBuf`对象后，**明确后续不会用到该对象时**，一定要记得手动调用`release()`**清空引用计数**，**否则会导致该缓冲区长久占用内存，最终引发内存泄漏**）
- **Netty-Channel的ByteBuf回收**（`Head、Tail`处理器在任何情况下，**其中至少会有一个，作为通道上的最后一个处理器调用**，而在**这两个头尾处理器中，会自动释放`ByteBuf`的工作**）

## 零拷贝

**调用内核函数的时候会发生上下文切换**

### Nginx文件下载（传统IO）

- 客户端请求下载服务器上的某个资源，**Nginx解析请求**并得知客户端要下载的具体文件
- Nginx向OS**发起系统IO调用**，**调用内核read**(fd)函数，应用上下文**切态至内核空间**。
- read()函数通过**DMA控制器**，将目标文件的数据**从磁盘读取至内核缓冲区**。
- DMA传输数据完成后，CPU**将数据从内核缓冲区拷贝至用户缓冲区**（程序的内存空间）。
- CPU**拷贝数据完**成后，read()**调用结束并返回**，上下文从**内核态切回用户态**。
- Nginx再次向**OS发起内核write(fd)函数**的系统调用，应用上下文再次**切到内核态**。
- 接着**CPU将用户缓冲区中的数据**，**写入到Socket网络套接字的缓冲区**。
- 数据复制到Socket缓冲区后，**DMA控制器**将Socket缓冲区的**数据传输到网卡设**备。
- DMA控制器**将数据拷贝至网卡设备后**，**write()函数调用结束**，**再次切回用户态**。
- 文件数据抵达网卡后，Nginx准备向客户端响应数据，组装报文返回数

**状态切换**：调用内核read（内核态）———–》read调用结束（用户态）———–》调用内核write（内核态）———–》write调用结束（用户态）

**数据拷贝**：磁盘读取至内核缓冲区（DMA）———–》内核缓冲区拷贝至用户缓冲区（CPU）———–》用户缓冲区至内Socket网络套接字的缓冲区（CPU）———–》数据拷贝至网卡（DMA）

### 操作系统零拷贝

#### MMAP共享内存+write

通过不同的虚拟地址，来操纵同一块物理内存，减少了一次**内核缓冲区到用户缓冲区的`CPU`拷贝过程**

#### sendfile()内核函数

支持直接数据从 磁盘 - 内核缓冲区 - socket缓冲区 - 网卡设备，减少了一次**内核缓冲区到用户缓冲区的`CPU`拷贝过程**；减少了两次状态切换

- 向`OS`发起系统`IO`调用，调用内核`sendfile()`函数，上下文切态至**内核空间**
- **DMA控制器**将目标文件的数据**从磁盘读取至内核缓冲区**。
- **CPU**将数据从**内核缓冲区**拷贝至**Socket缓冲区**
- **DMA控制器**将数据从**Socket缓冲区**拷贝至**网卡设备**
- **切回用户态空间**，客户端响应数据，组装报文返回数据

#### DMA-Scatter/Gather Copy - sendfile()函数

支持直接数据从 磁盘 - 内核缓冲区 - 网卡设备，减少了一次**内核缓冲区到用户缓冲区的`CPU`拷贝过程**；减少了两次状态切换

- 向`OS`发起系统`IO`调用，调用内核`sendfile()`函数，上下文切态至**内核空间**
- **DMA控制器**将目标文件的数据**从磁盘读取至内核缓冲区**。
- **DMA控制器**将数据从**内核缓冲区**拷贝至**网卡设备**
- **切回用户态空间**，客户端响应数据，组装报文返回数据

### 应用程序中零拷贝

**缓存区共享**（**内核缓冲区和用户缓冲区共享同一块内存**）

#### NIO

- MappedByteBuffer.map()：底层调用了操作系统的mmap()内核函数。
- DirectByteBuffer.allocateDirect()：可以直接创建基于本地内存的缓冲区。
- FileChannel.transferFrom()/transferTo()：底层调用了sendfile()内核函数

### Netty的零拷贝实现

- **使用堆外本地内存**创建ByteBuf缓冲区，减少了堆内存和直接内存之间的拷贝过程
- **文件传输**采用了`transferTo()/transferFrom()`方法，它可以**直接将文件缓冲区的数据发送到目标`Channel（Socket）`**，底层就是调用了**`sendfile()`内核函数**，**避免了文件数据的`CPU`拷贝过程**
- 提供了**组合、拆解ByteBuf对象的API**；过程中不会出现数据拷贝

## 粘包、半包问题

**粘包**

- **应用层**：**接收方的接收缓冲区太大**，导致读取多个数据包一起输出
- **TCP滑动窗口**：**接收方窗口较大，导致发送方发出多个数据包，处理不及时造成粘包**
- **Nagle算法**：由于**发送方的数据包体积过小**，导致多个数据包合并成一个包发送

**半包**

- **应用层**：**接收方缓冲区太小**，无法存方发送方的单个数据包，因此拆开读取
- **滑动窗口**：**接收方的窗口太小**，无法一次性放下完整数据包，只能读取其中一部分
- **MSS限制**：**发送方的数据包超过MSS限制**，被拆分为多个数据包发送

### Netty解决方案

- **短连接**（投机，不能解决半包，长时间开启关闭性能消耗大）
- **定长帧解码器**（**适用传输固定长度范围内的数据场景**；**超出固定长度半包**；**未达到需要补齐，占用网络资源**）
- **行帧解码器**（定长解码器 + 换行符；**小于定长的不会出现半包现象，大于定长会出现半包**；**需要逐个判断分隔符**）
- **自定义分隔符解码器**（定长解码器 + 自定义分隔符；**小于定长的不会出现半包现象，大于定长会出现半包**；需要逐个判断分隔符）
- **LTC帧解码器**（确定一条数据的长度，位置，从而获取到精确的数据）
  - maxFrameLength：数据最大长度，**允许单个数据包的最大长度**，超出长度后会自动分包。
  - lengthFieldOffset：长度字段偏移量，表示**描述数据长度的信息从第几个字段开始**。
  - lengthFieldLength：**长度字段的占位大小**，表示数据中的使用了几个字节描述正文长度。
  - lengthAdjustment：长度调整数，表示在**长度字段的N个字节后才是正文数据的开始**。
  - initialBytesToStrip：头部剥离字节数，**表示先将数据去掉N个字节后，再开始读取数据**

## 长连接

- **TCP_NODELAY**：开启TCP的Nagle算法，会将多个小包合并成一个大包发送

- **SO_KEEPALIVE**：开启长连接机制，一次数据交互完后不会立马断开连接

- **需要改一下服务端客户端代码**

  ```
  // 服务端代码
  server.childOption(ChannelOption.SO_KEEPALIVE, true);
  
  // 客户端代码
  client.option(ChannelOption.SO_KEEPALIVE, true);
  ```

## 心跳机制

**基于TCP长连接实现，2小时一次，太久**

**客户端实现**

- **HeartbeatClientHandler**中定义**userEventTriggered**（心跳发送方法）
- pipeline.addLast("IdleStateHandler", new IdleStateHandler(0,3,0,TimeUnit.SECONDS)) （**读操作的闲置事件、写操作的闲置事件、读写操作的闲置事件**；为0则不触发）

**服务端实现**

- **HeartbeatClientHandler**中定义**userEventTriggered**（关闭未发送心跳包的连接）
- pipeline.addLast("IdleStateHandler", new IdleStateHandler(5,0,0,TimeUnit.SECONDS)); （**读操作的闲置事件、写操作的闲置事件、读写操作的闲置事件**；为0则不触发）

# 面试-实现一个IM及时通信程序

## 文本传输协议

服务端的`pipeline`上添加了一个`HttpServerCodec`处理器

## 用户模块

通过代码块的方式，加载了`ZhuZi、XiongMao`**两个用户信息并放入内存**的`Map`容器中

```
public class UserServiceMemoryImpl implements UserService {
    private Map<String, String> allUserMap = new ConcurrentHashMap<>();
    
    {
        // 在代码块中对用户列表进行初始化，向其中添加了两个用户信息
        allUserMap.put("ZhuZi", "123");
        allUserMap.put("XiongMao", "123");
    }

    @Override
    public boolean login(String username, String password) {
        String pass = allUserMap.get(username);
        if (pass == null) {
            return false;
        }
        return pass.equals(password);
    }
}
```

## 服务端、客户端的基础架构

服务端在之前基础基础上 **装载了一个自己的协议编/解码处理器**

客户端与服务端建立了连接，然后**装载了一个自定义的编解码器**

```
public class ChatServer {
    public static void main(String[] args) {
        NioEventLoopGroup boss = new NioEventLoopGroup();
        NioEventLoopGroup worker = new NioEventLoopGroup();

        ChatMessageCodec MESSAGE_CODEC = new ChatMessageCodec();

        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.group(boss, worker);
            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) throws Exception {
                    ch.pipeline().addLast(MESSAGE_CODEC);
                }
            });

            Channel channel = serverBootstrap.bind(8888).sync().channel();
            channel.closeFuture().sync();
        } catch (InterruptedException e) {
            System.out.println("服务端出现错误：" + e);
        } finally {
            boss.shutdownGracefully();
            worker.shutdownGracefully();
        }
    }
}

public class ChatClient {
    public static void main(String[] args) {
        NioEventLoopGroup group = new NioEventLoopGroup();

        ChatMessageCodec MESSAGE_CODEC = new ChatMessageCodec();

        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(group);
            bootstrap.handler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) throws Exception {
                    ch.pipeline().addLast(MESSAGE_CODEC);
                }
            });
            Channel channel = bootstrap.connect("localhost", 8888).sync().channel();
            channel.closeFuture().sync();
        } catch (Exception e) {
            System.out.println("客户端出现错误：" + e);
        } finally {
            group.shutdownGracefully();
        }
    }
}
```

## 用户登录功能

**消息对象用于传输数据**

### **父类**

（多种**消息类型的状态码**，不同的消息类型对应不同数字，同时其中还设计了一个**抽象方法**，即`getMessageType()`）

```
public abstract class Message implements Serializable {

    private int sequenceId;
    private int messageType;


    @Override
    public String toString() {
        return "Message{" +
                "sequenceId=" + sequenceId +
                ", messageType=" + messageType +
                '}';
    }

    public int getSequenceId() {
        return sequenceId;
    }

    public void setSequenceId(int sequenceId) {
        this.sequenceId = sequenceId;
    }

    public void setMessageType(int messageType) {
        this.messageType = messageType;
    }

    public abstract int getMessageType();

    public static final int LoginRequestMessage = 0;
    public static final int LoginResponseMessage = 1;
    public static final int ChatRequestMessage = 2;
    public static final int ChatResponseMessage = 3;
    public static final int GroupCreateRequestMessage = 4;
    public static final int GroupCreateResponseMessage = 5;
    public static final int GroupJoinRequestMessage = 6;
    public static final int GroupJoinResponseMessage = 7;
    public static final int GroupQuitRequestMessage = 8;
    public static final int GroupQuitResponseMessage = 9;
    public static final int GroupChatRequestMessage = 10;
    public static final int GroupChatResponseMessage = 11;
    public static final int GroupMembersRequestMessage = 12;
    public static final int GroupMembersResponseMessage = 13;
    public static final int PingMessage = 14;
    public static final int PongMessage = 15;
}
```

### **中间类**

（**响应状态以及响应信息**，方便后续拓展）

```
public abstract class AbstractResponseMessage extends Message {
    private boolean success;
    private String reason;

    public AbstractResponseMessage() {
    }

    public AbstractResponseMessage(boolean success, String reason) {
        this.success = success;
        this.reason = reason;
    }

    @Override
    public String toString() {
        return "AbstractResponseMessage{" +
                "success=" + success +
                ", reason='" + reason + '\'' +
                '}';
    }

    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public String getReason() {
        return reason;
    }

    public void setReason(String reason) {
        this.reason = reason;
    }
}
```

### **两个登录时会用到的消息对象**

```
public class LoginRequestMessage extends Message {
    private String username;
    private String password;

    public LoginRequestMessage() {
    }

    @Override
    public String toString() {
        return "LoginRequestMessage{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                '}';
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public LoginRequestMessage(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @Override
    public int getMessageType() {
        return LoginRequestMessage;
    }
}


public class LoginResponseMessage extends AbstractResponseMessage {
    public LoginResponseMessage(boolean success, String reason) {
        super(success, reason);
    }

    @Override
    public int getMessageType() {
        return LoginResponseMessage;
    }
}
```

在**与服务端建立连接成功之后**，就提示用户需要登录，接着**接收用户输入的用户名、密码**，然后构建出一个`LoginRequestMessage`消息对象，接着将其**发送给服务端**，由于**前面装载了自定义的协议编解码器**，所以消息在出站时，这个`Message`对象**会被序列化成字节码**，接着**再服务端入站时，又会被反序列化成消息对象**

```
CountDownLatch WAIT_FOR_LOGIN = new CountDownLatch(1);
AtomicBoolean LOGIN = new AtomicBoolean(false);
AtomicBoolean EXIT = new AtomicBoolean(false);
Scanner scanner = new Scanner(System.in);
        
ch.pipeline().addLast("client handler", new ChannelInboundHandlerAdapter() {
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        // 负责接收用户在控制台的输入，负责向服务器发送各种消息
        new Thread(() -> {
            System.out.println("请输入用户名:");
            String username = scanner.nextLine();
            if(EXIT.get()){
                return;
            }
            System.out.println("请输入密码:");
            String password = scanner.nextLine();
            if(EXIT.get()){
                return;
            }
            // 构造消息对象
            LoginRequestMessage message = new LoginRequestMessage(username, password);
            System.out.println(message);
            // 发送消息
            ctx.writeAndFlush(message);
            System.out.println("等待后续操作...");
            try {
                // 模拟线程等待，释放锁
                WAIT_FOR_LOGIN.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 如果登录失败
            if (!LOGIN.get()) {
                ctx.channel().close();
                return;
            }
    }).start();
}
```

**单人聊天直接进行通信即可**

**多人聊天维护了一个群组信息**

**private** **final** Map<String, Group> groupMap = **new** **ConcurrentHashMap**<>();

==后边有时间自己动手实践补充==

# 序列化详解

## JDK序列化

（**实现空接口，JDK判断能否被序列化**；serialVersionUID，反序列化进行验证；transient**标识属性是否进行序列化**）—–通过**程序的字节输入输出流实现**

```
/**
     * 序列化方法
     * @param zhuZi 需要序列化的对象
     * @return 序列化后生成的字节流
     */
    private static byte[] serialize(ZhuZi zhuZi) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(zhuZi);
        return bos.toByteArray();
    }

    /**
     * 反序列化方法
     * @param bytes 字节序列（字节流）
     * @return 实体类对象
     */
    private static ZhuZi deserialize(byte[] bytes) throws Exception {
        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
        ObjectInputStream ois = new ObjectInputStream(bis);
        return (ZhuZi) ois.readObject();
    }
```

**缺陷**

- **性能最差**
- **不支持多语言异构**（除java以外不能识别码流）
- **成的码流体积太大**（对象状态，继承信息，引用信息）

## Json序列化

**比`JDK`序列化后的体积，大概小了五倍左右**（**适用于HTTP传参**，分布式RPC，游戏数据，IM消息不太合适）

- **先转流再转字符串**
- **明文形式**
- **体积依旧较大**

## Protocol Buffer序列化

**优点**

- 支持**异构**，序列化生成的数据多语言之间可识别
- 使用**二进制编码**，序列化、反序列化时的性能更快
- **紧凑的数据结构**，序列化后的码流体积更小，网络传输效率更佳

**缺点**

- **不能直接阅读**
- **ProtoBuf生成的Java代码改造成本大**
- **基本数据类型支持，`Map<String,List<Map<Object,Object>>>`这种类型构造不出来**（`Any`类型来支持特殊类型）
- **新版本不支持继承**

## Hessian序列化

- **码流体积小了3.2倍**
- **保留了JDK序列化技术的特性**
- **还支持多语言异构**

**比较**

体积：**`ProtoBuf`最佳，`Json`其次，`Hessian2`第三，`JDK`最后**

编码效率：**`ProtoBuf`最佳，`Json`其次，`Hessian2`第三，`JDK`最后**