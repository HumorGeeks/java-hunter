#  面试-JVM

## JDK、JRE与JVM之间的关系

- JDK：Java的**SDK开发工具包**
- JRE：运行时环境；包含JavaAPI、JVM在内，提供了Java程序执行的**最低的环境要求**
- JVM：为Java**字节码的执行**提供了保障

**类加载子系统**—>**执行引擎子系统**—>**运行时数据区**—>**垃圾回收子系统**—>**本地接口和本地方法库**

# 面试-类加载子系统

**类加载子系统**将这些**字节码文件先装载进内存**

**类加载**：JVM需要**用到某个类**；虚拟机会**加载它的.class文件**；**创建对应的Class对象**；

## **类加载过程**

- **加载**
  - 通过一个类的全限定名来获取定义此类的二进制流
  - 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 内存中生成一个.class对象，作为方法区这个类的各种数据访问接口
- **验证**
  - **文件格式验证**
    - 是否以魔数0xCAFEBABE开头
    - 主、次版本号是否在当前Java虚拟机接受范围之内
    - 常量池是否有不支持的常亮、是否有不存在的常量
    - UTF8编码
    - Class文件中信息
  - **元数据验证**
    - 是否继承了不允许继承的类
    - 非抽象类是否实现了其他类或者接口之中要实现的所有方法
    - 字段方法是否与父类产生矛盾
  - **字节码验证**
    - 通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑
  - **符号引用验证**
    - 该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源
- **准备；解析**
  - **静态变量分配内存空间**
  - **类方法解析**
  - **接口方法解析**
- **初始化**
  - **为静态变量赋值**
  - **执行static代码块**
  - **执行类构造器方法**
- **使用和卸载**
  - 虚拟机**自带的类加载器加载的类**，在虚拟机的生命周期中始终不会被卸载

## 类加载器顺序

加载过程中会**先检查类是否被已加载**，检查顺序是**自底向上**，从Custom ClassLoader到BootStrap ClassLoader**逐层检查**，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而**加载的顺序是自顶向下**，也就是由上层来逐层尝试加载此类

- **Bootstrap ClassLoader**

  加载$JAVA_HOME中jre/lib/rt.jar里所有的class

- **Extension ClassLoader**

  加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

- **App ClassLoader**

  加载classpath中指定的jar包及目录中class

- **Custom ClassLoader**

  应用程序根据自身需要自定义的ClassLoader

- 当前ClassLoader**首先从自己已经加载的类中查询是否此类已经加载**【**ClassLoaderId类加载器 + PackageName包名 + ClassName类名称**】，如果**已经加载则直接返回**原来已经加载的类

- 当前classLoader的缓存中**没有找到**被加载的类的时候，**委托父类加载器去加载**，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，**一直到bootstrp ClassLoader**

- 当**所有的父类加载器都没有加载**的时候，**再由当前的类加载器加载**，并将其**放入它自己的缓存**中，以便下次有加载请求的时候直接返回

## 双亲委托模型

- 当前ClassLoader**首先从自己已经加载的类中查询是否此类已经加载**【**ClassLoaderId类加载器 + PackageName包名 + ClassName类名称**】，如果**已经加载则直接返回**原来已经加载的类
- 当前classLoader的缓存中**没有找到**被加载的类的时候，**委托父类加载器去加载**，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，**一直到bootstrp ClassLoader**
- 当**所有的父类加载器都没有加载**的时候，**再由当前的类加载器加载**，并将其**放入它自己的缓存**中，以便下次有加载请求的时候直接返回

## 为何采用双亲委派机制

- **防止类的重复加载**
- 保护程序安全、**防止核心API被篡改**

## 热部署

- **销毁该自定义ClassLoader**
- **更新class类文件**
- **创建新的ClassLoader去加载更新后的class类文件**

## 为什么要破坏双亲委托

- **实现可拔插机制**【**mysql的Driver接口定义在jdk当中**的，而其**实现由各个数据库的服务商来提供**，**启动类加载器来委托子类**来加载Driver实现】
- 加载流程
  - Bootstrap加载Java核心类(核心类中包含Launcher类)
  - 初始化并创建Ext、App类加载器
  - 将Ext设置为App的父类加载器 → 同时再**将App设置为默认的线程上下文类加载器**
  - Bootstrap**加载接口的时候**；**委托子类 App ClassLoader**依赖**SPI的动态服务发现机制**加载META-INF/services路径下的实现类；

# 面试-执行引擎子系统

将**字节码指令**解释/编译成对应平台上的**本地机器指令**

## 执行技术

- 解释执行：**用到某处代码**时，转换为机器码执行
- 静态编译：程序在**启动前**，编译成对应平台的机器码
- 即时编译：运行过程中，**执行比较频繁**的代码转换机械码并**存储**下来
- 自适应优化：**经常调用的方法启动一个后台线程**，将其**编译为本地代码，并进行仔细优化**
- 芯片级直接执行：**直接编写**机器码的

## 执行引擎工作过程

### javac编译过程

- **词法分析**：先读取源代码的**字节流数据**，然后根据源码语言的语法规则**找出源代码中的定义的语言关键字**，如if、else、while、for等，然后判断这些关键字的定义是否合法，对于合法的关键字生成用于语法分析的记号序列，同时创建符号表，将**所有的标识符记录在符号表【收集属性信息】中**，**这个过程就被称为词法分析**。
- **语法分析**：对**词法分析后得到的Token流**进行**语法分析**，就是依据源程序的语法规则，**检查这些关键词组合在一起是否符合Java语言规范**，比如if的后面是不是紧跟着一个布尔型判断表达式、else是否写在if后面等。对于符合规范的，组织上一步产生的记号序列生成语法树。形成一颗符合Java语言规定的抽象语法树。抽象语法树是一个结构化的语法表达形式，它的作用是**把语言的主要词法用一个结构化的形式组织在一起**，这棵语法树可以被后面按照新的规则再重新组织。
- **语义分析**：经过语法分析后就不存在语法错误这些问题了，语义分析主要任务有两个，一个是对上步产生的**语法树进行检查**，其中包括类**型检查、控制流检查、唯一性检查**等，第二个则是将一些**复杂的语法转换为更简单的语法**，相当于把一些文言文、古诗、成语翻译成大白话的意思。比如将foreach转化为for循环、循环标志位替换为break等。
- **字节码生成**：将简化后的语法树转换为Class文件的格式，也就是在该阶段会**根据简化后的语法树生成字节码**。

### 执行引擎执行过程

- 编译器代码优化
- 机械相关优化
- 寄存器分配优化
- 目标代码生成器
- 本地机械指令

## JVM执行引擎子系统

**解释器**

**执行**一个方法或某处代码，根据定义的规范，**对每条需执行的字节码指令逐行解释**

**JIT及时编译**

**执行次数比较频繁的代码**直接编译成本地机器码

**如何判断热点代码**

- 方法调用计数器（Client1500，Server10000；根据**方法调用次数**）
- 回边计数器（**循环体的执行次数**）

方法调用计数器统计的**执行次数并不是绝对次数**；**热度衰减**：当超过一定的时间，但计数器还是未达到编译阈值**无法提交给JIT即时编译器编译时，那此时就会**对计数器进行减半**

- 采样探测

  周期性的检查每个线程的**虚拟机栈栈顶**；经常出现在栈顶的方法

  - 优点：实现简单
  - 缺点：无法实现精准探测

- 踪迹探测

  将一段频繁执行的代码**作为一个编译单元**；对该单元进行编译

  - 优点：实现复杂
  - 缺点：实现精准探测

## 为何保留解释器

- 保证**绝对的跨平台性**：移除就代表着：**每到一个不同的平台**，比如从Windows迁移到Linux环境，那么JIT**又要重新编译**
- 保证**Java启动速度**：**所有的字节码指令**全部编译为机器码指令，需要的**时间开销是非常巨大**的

## 冷热机切换

- 热机：很多代码都已经被JIT编译为了本地机器码指令
- 冷机：刚刚启动的Java程序的机器，所有代码还是处于**解释执行**的阶段
- 切换方案
  - **更多的机器**承载热机状态过来的流量，等后续这些刚启动的冷机变成热机状态了，可以**再把多余的机器停掉**
  - **网关冷机预热**然后在进行流量迁移

## 即时编译器

- C1：（公共子表达式消除，方法内联，去虚拟化，冗余消除）追求编译速度
- C2：（逃逸分析【对象被赋值给类属性、静态属性；对象被当作参数传递给另一个方法；对象被当做返回值】；标量替换；栈上分配；同步消除【synchronized嵌套，第二个会失效】）

## 多态性如何确定调用哪个方法

- 静态分派（依赖于**方法参数静态类型**来**定位方法执行版本的分派**）
- 动态分配（**运行期根据实际类型确定方法执行版本的分派**）

# 面试-运行时数据区

## 线程共享区

- **堆空间**（**运行时内存**）

  系统运行过程中产生的大部分**实例对象**以及**数组对象**；**逻辑连续，内存不连续**；

  - **分代（JDK7及以前）**可以通过参数配置

    **新生成**首先放到年轻代Eden区；**Eden满**触发**Minor GC**、存**活下来的对象移动到Survivor0（from）区**，**Survivor0区满后触发执行MinorGC**、Survivor0区存活对象移动到Suvivor1区；**多次Minor GC仍然存活的对象**移动到老年代【15次GC之后】

    - 新生代：一个Eden区【**刚创建出来**】、两个Survivor区（Form/To区），比例：8:1:1
    - 年老代：一个Old区
    - 永久代：方法区

  - **JDK8**

    **移除了方法区**，在**本地内存中**加入了**元数据空间**来**存储之前方法区中的大部分数据**

  - **JDK9**（划分为多个大小相等的独立的`Region`区域）

    - 区别于1.7的是**大对象（超过单个Region50%）直接将其放入Humongous区存储**【避免一些“短命”的**巨型对象**直接进入年老代】
    - 发生**全局GC**，回收**新生代，年老代和Humongous**

  - **JDK11**（**不分代**）

    - 小型区（2M，小于256K存储）
    - 中型区（32M，小于4M存储）
    - 大型区（2M整数倍；**每个Large区只能存放一个大对象**）

  - 在Survivor区中**相同年龄的所有对象大小**总和**大于Survivor空间的一半**；**不用阈值直接晋升**

- **本地内存**（**运行时内存**）

  - **元数据空间**

    存放**运行时常量池**和**类信息**（移除了之前版本的方法区中【永久代】**字符串**和**静态常量**；使其能够进行GC）

    - 方法区**不容易设置大小**，容易产生OOM
    - 垃圾回收机制**对于永久代的回收效率比较低**

  - **本地内存**

    **不是虚拟机的内存区域**，创建时会**直接向操作系统申请内存空间**；**需要自己做回收**

## 线程私有区

**随着线程的启动、死亡而创建和销毁**

- **程序计数器**（**不发生GC**；**指向正在执行的指令地址**；**处理完后更新为下一条地址**；**CPU切换后可以正常执行**）

- **虚拟机栈**

  - **局部变量表**（**对象的引用信息**、**方法参数**以及**方法体内定义的基本数据类型变量**、对象引用以及**返回地址**等信息）
  - **操作数栈**（**保存计算过程的中间结果**，同时作为**计算过程中变量临时的存储空间**）
  - **动态链接**（**每个栈帧**都包含一个**指向运行时常量池中该栈帧所属方法的引用**；**符号引用转换为调用方法的直接引用**）
  - **方法出口**（正常返回；异常出口【**复原**上层方法的**局部变量表以及操作数栈**；把**返回值压入调用者方法栈帧的操作数栈**；**将PC计数器的地址指向改为方法下一条指令的位置**】）

  当前线程请求的**栈深度**大于**虚拟机栈所允许的深度**时抛出该异常

  **扩展时无法申请到足够的内存空间**会抛出`OOM`异常

- **本地方法栈**

  用于执行C所编写的**Native本地方法**

# 面试-OOM

## 线上OOM原因

- 内存中**加载数据量过于庞大**
- **集合对象中存在对象的引用**，使得集合中的一些失效对象无法被GC回收
- 代码中存在**逻辑不正确**产生了大量重复的**对象实例**
- 第三方依赖中存在BUG，导致**运行时生成大量对象**
- JVM启动时，使用参数为其**分配的堆空间过小**
- **无限递归调用**
- **系统流量超出原有的预估值**，导致大量请求进入系统，创建大量对象

## 线上OOM问题排查

- **堆空间OOM**
  - 代码问题
  - 分配堆空间过小（加大堆内存）
  - 内存泄漏
  - GC overhead limit exceeded（加大堆内存）
- **本地方法栈和虚拟机栈OOM**
  - **局部变量表**位于**栈帧**之中；方法的入参数量定义**成不确定的个数**；大量参数**导致溢出**
  - **解决方案**
    - SOF问题（无限递归）【优化代码】
    - **unable to create new native thread**（线程数**超过了操作系统最大线程数**；线程数**超过一个内核内存映射数**；物理机**内存被耗尽**）【升级硬件配置，】
- **元数据空间和运行时常量池OOM**
  - **加载的类信息过多**
  - JIT**生成的热点代码过多**
  - **运行时常量池溢出**
  - **解决方案**
    - 为cglib生成了大量的代理类；XX:+CMSClassUnloadingEnabled `和`-XX:+UseConcMarkSweepGC，**允许JVM卸载类**
    - **调大分配的空间**
- **直接内存OOM**
  - 申请后**没有合理释放**
  - 因为**申请的内存大小超出了直接内存的可用内存大小**

## 内存泄漏

**固定占用后不能被释放**

## 其他内存溢出

- **Out of swap space**（虚拟内存已被耗尽）

  解决方案：提升硬件配置

- **Kill process or sacrifice child**（Linux**内存用尽**，内核打分，**尝试杀掉低分进程**）

- **Requested array size exceeds VM limit**（程序**请求创建的数组超过最大长度限制**）

# 面试-对象生命周期

## 对象内存布局

**对象头** + **实例数据** + **对其填充**【**必须要为8的整数倍**】（指针压缩【对**引用类型进行压缩**；】）

**指针压缩后**需要对对象进行**寻址计算**

- 高位地址小于`32GB`；add=0+offset∗8
- 高位大于等于`32GB`；add*=*base*+*offset
- 如果堆空间大小处于4GB与32GB之间：add*=*base+offset∗8

### 一个Object占用多少内存

- **标记位**【4byte】 + **类对象**【8byte】 + **对齐**（16bytes=128bit）

### 一个数组对象占用多少内存

- **标记位**【4byte】 + **类对象**【8byte】+ 9【数组长度】* 4=36bytes数组空间 + **对齐**

### 一个实例对象占用多少内存

- **标记位**【4byte】 + **类对象**【8byte】+ **其他各属性长度** + **引用占用字节数** + **对齐**

## 对象分配过程

- 类加载检测

  - 当前**类加载器**以当前**创建对象的全限定名**查找对应Class文件

- 内存分配

  - **栈上分配**（尝试分配，超过大小不分配）
  - **TLAB分配**（**为每个线程划分出来的**）
    - TLAB**可以放下**，直接分配
    - **放不下**；**剩余空间**是否**大于规定的最大空间浪费大小**；大于则直接**在堆上**进行分配；不大于填充内存间隙；将**当前TLAB退回**堆空间（**通过引用指针访问**），重新申请
  - **年老代分配**
    - TLAB区尝试分配失败，**大对象直接进入年老代**
  - **新生代分配**（Eden区尝试新生代分配）
    - 指针碰撞（**已用分配内存**和**为分配的空闲内存分别会处于不同的一侧**；**把指针往空闲的一端移动与对象大小相等的距离即可**）
    - 空闲列表（内存列表记录，挑选一个适合的）

- 初始化内存

  JVM会**将分配到的内存空间**（不包括对象头）**都初始化为零值**;避免不赋值直接访问导致的空指针异常

- 设置对象头

  - **哈希码**、**GC年龄**、锁标志、**锁信息**组装成**MrakWord**
  - **类型指针**`KlassWord`也加入对象头中
  - 数组对象还包括**数组长度**

- 执行构造函数

  - 对属性进行**显式赋值**

## 空间分配担保

一个**S区空间无法储存Eden区和另外一个S区的存活对象**时，这些对象会被直接**转移到年老代**，这个过程就是空间分配担保（在进行**MinorGC前**，如果**老年代的连续空间大于新生代对象大小总和或历次晋升的平均大小**，如果大于，则此次MinorGC是安全的，则**进行MinorGC**，**否则进行FullGC**）

## 对象访问方式

- **句柄访问**

  划分出一块内存区域作为**句柄池**；**存储所有引用的地址**

- **直接指针访问**

  **对象在堆中的内存地址**

- 线程执行完后，局部变量表**引用会被回收**，下一次GC发生前**还是没有新的指针**引用它，则被**回收**；**还存在引用，移动到Eden，更新内存地址**

## 对象引用类型

- **强引用**（**new指令**创建的Object实例会被分配在**堆中存储**；变量obj会被**放在当前方法对应的栈帧内的局部变量表**中存储）
- **软引用**（**SoftReference类型修饰**；**内存不足的情况可以被回收**）【JVM级别的简单缓存】
- **弱引用**（**WeakReference**修饰；只要被GC发现就回收）【栈帧中，强引用对象**和弱引用对象存在联系**；GC时不会回收它】
- **虚引用**（**PhantomReference**修饰，**随时随刻可以回收它**；跟踪垃圾回收过程，将一些资源释放操作放置在虚引用中执行和记录）

# 面试-GC

堆空间和元数据是**共享区域**；**处于运行期间时才能知道会具体创建哪些对象**;**内存分配和回收都是动态的**

## 垃圾判定

### **引用计数**

- 实例**被创建，初始化为1**
- **多一个变量引用，引用计数器会+1**；
- **局部变量表**中**引用该对象的指针随之销毁**时对象的引用计数器会-1；
- 对象的**计数器为0时**，代表当前对象已经**没有指针引用它**

**优点**

- **实现简单**，**判断效率高**，**回收没有延迟**

**缺点**

- **每次**引用**指向或消失时都需要同步更新计数器**
- **不能解决循环引用**

### **可达性分析**

以这些**GCRoots**作为根节点；从上至下的方式进行**搜索分析**有无引用链

- **虚拟机栈**中引用的对象
- **元数据空间中类静态属性**引用的对象
- **元空间运行时常量池**中常量引用的对象
- **本地方法栈**中JNI（native方法）中引用的对象
- **被synchronized**持有的对象

## 对象finalize机制

垃圾回收器**发现一个对象没有引用指向时**；**GC之前**调用这个**对象的finalize()方法【只会执行一次】**；建立引用可以再次重合

## 垃圾回收

**内存不足**的情况；发生**STW**；将JVM中的所有用户线程暂停

### **标记清除**

- 通过**可达性算法**；初始化为0，**清除对象标记为1**
- 清除完恢复
- **缺点**
  - **STW**
  - **遍历整个堆空间中的所有GcRoots**
  - 大量的**内存碎片**

### 复制

- **内存一分为2**

- 复制可用对象到另一半

  **缺点**：

  **内存浪费**（8 ： 1 ：1；浪费 10%）

  **对象过多复制慢**

### 标记整理

- 通过**可达性算法**；初始化为0，**清除对象标记为1**
- 将所有存活对象移动（压缩）到**内存的一端**，然后对于**存活对象边界之外的内存进行统一回收**
- 时间过长（**解决了内存碎片和空间浪费**）

### 分代收集

### 新生代

- 复制算法（**少量对象存活**），**少量的内存空间开销**以及**少量存活对象的移动开销**，换取**内存的整齐度**以及可观收集效率

### 老年代

- **标-整算法**（内存整齐有利于大对象分配）

## 为什么要STW

- 避免浮动垃圾
- 确保内存一致性

## STW问题

- 客户端无响应
- HA**产生脑裂问题**
- 上游宕机

## 收集类型

- 新生代YoungGC（**Eden区满**了才会触发）
- 年老代收集（MajorGC，**老年代满**了）
- 混合收集（整个空间）
- 全面收集（FullGC 新生 + 老年 + 元数据空间）

## 分代收集

### 新生代

#### Serial收集器（单线程）

- **串行GC**，**单线程**，**复制算法**，**需要STW**

#### ParNew收集器（多线程）【**响应时间**】

- **并行GC，多线程【根据CPU核数开启】，复制算法，需要短暂STW**

#### Parallel Scavenge收集器（多线程）【吞吐量】

- **并行GC，多线程【根据CPU核数开启】，复制算法，需要短暂STW**

### 老年代

#### Serial Old（MSC）收集器（单线程）

- **串行GC**，**单线程**，**标记整理算法**，**需要STW**

#### Parallel Old收集器（多线程）【吞吐量】

- **并行GC，多线程【根据CPU核数开启】，标记整理算法，需要短暂STW**

#### CMS收集器（多线程/并发，**停顿延迟低**）【**最短的回收时间**】

- **并发GC，多线程并行，算法：标记-清除算法**
- **收集过程**
  - **初始标记**：仅标记**GcRoot节点直接关联**的对象
  - **并发标记**：**该阶段主要是做GC溯源工作**
  - **重新标记**：这个阶段主要是为了**修正“并发标记”阶段由于用户线程执行造成的GC标记变动的那部分对象**
  - **并发清除：在该阶段主要是对存活对象之外的垃圾对象进行清除**
- 存在问题：**内存碎片，浮动垃圾**，需要加上**Serial Old**【框架匹配】

## 分区回收高性能收集器

### G1收集器（**期望停顿时间**）

**多线程并行GC**，**标记整理算法**，**需要STW**

- **2048个Region区**【也可强制指定大小】
- **Eden**区和**Survivor**区对应的Region区比例也跟之前一样，默认8:1:1
- **分配对象**时，判定出**一个对象属于大对象**，那么则会**直接将其放入Humongous区存储**

#### 三种GC类型

- **YoungGC**

  **Eden区**放满了就会立马被触发

- **MixedGC**

  会回收**所有新生代Region区**、**部分年老代**Region区（会根据**期望的GC停顿时间选择合适的年老代Region区优先回收**）**以及大对象Humongous区**

- **FullGC**

  **整个堆空间中的空闲Region不足**以支撑拷贝对象或由于元数据空间满了等原因触发

#### 回收过程

- **初始标记**（InitialMark）：先触发STW，然后使用**单条GC线程快速标记GCRoots直连的对象**。
- **并发标记**（ConcurrentMarking）：**采用多条GC线程与用户线程共同执行，根据Root根节点标记所有对象**。
- **最终标记**（Remark）：同CMS的重新标记阶段，主要是为了**纠正并发标记阶段因用户操作导致的错标、误标、漏标对象**。
- **筛选回收**（Cleanup）：先**对各个Region区的回收价值和成本进行排序，找出「回收价值最大」的Region优先回收**。

#### 如何解决漏标

##### STAB解决分配对象漏标问题

**标记前**通过RootTracing生成的一张**堆空间存活对象快照**，**新分配的对象也会被标记为存活对象**【nextTAMS ~ top指针之间是新分配的对象始终存储新对象】

##### STAB+写屏障解决引用更改对象的漏标问题

发标记过程中，跟着**最开始的对象图关系**进行标记【**写屏障实现**】

#### 如何解决跨代

- **RSet记录了我引用了谁的对象**
- **YGC**，选定目标**新生代Region的RSet作为根集**；**MixedGC**，Old → Young的跨代引用可以**从Young类型的Region中得到**

### ZGC（超低延迟与吞吐量，64位）

**超大级别堆空间**，**触发产生的停顿时间不会偏差10ms**

- **小型区**（2MB；《256KB）
- **中型区**（32MB；《4M）
- **大型区**（没有固定大小）

#### 回收过程

- **初始标记**：**STW**，**标记根可直达的对象**，**压入到标记栈**中（重置 TLAB、判断是否要清除软引用）
- **并发标记**：根据初始标记根对象**开启多条GC线程**，并发遍历对象图，同时也会**统计每个分区/页面中的存活对象数量**。
- **再次标记**：**标记漏标**的对象（**时间过长再次进入并发重新标记**）
- **重置转移集/表**：【旧地址——-新地址】
- **回收无效分区/页面**：**回收物理内存已经被释放的无效的虚拟内存页面**
- **选择待回收的分区/页面**：筛选出**回收价值最大的页面**【**颜色指针**】来作为本次GC回收的目标
- **初始化待转移集合的转移表**
- **初始转移**：**STW**，**遍历所有GCRoots节点及其直连对象**，转移根对象
- **并发转移**：根对象出发，遍历目标区域中的所有对象，做并发转移处理

#### 颜色指针并发处理【所有的GC信息保存在对象头】

- 第一次GC发生前；**Remapped**
- 第一次扫描，GC线程开始标记，**根节点可达**，**标记为M0**，如果为M0不做处理
- **用户新创建**标记为**M0**
- 对象的**成员变量所引用的对象**都进行**递归标记**
- 标记结束所有的**M0状态的活跃对象**都会被放入**活跃信息表**

#### 如何解决对象漏标

- **读屏障**（利用**读屏障**通过指针上的标志来**判断对象是否被转移**，如果读取的对象已经被**转移**，那么则**修正当前对象引用为最新地址**）

#### 什么时候触发

- **定时触发**，默认不适用
- **预热触发**，10%、20%、30%时触发
- **分配速率**：计算**内存99.9%可能的最大分配速率**，**以及此速率下内存将要耗尽的时间点**，在**耗尽之前**触发GC「耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间」
- **主动触发**：**距上次GC堆内存增长10%，或超过5分钟时**

#### 总结

- 64位指针实现颜色指针
- 浮动垃圾
- **只会在处理根节点等阶段**才会出现STW
- 标记的是指针而并非对象

### ShenandoahGC【G1修订版】

- **初始标记**：短暂STW，标记GCRoots**直达对象**
- **并发标记阶段**：和用户线程一同工作，从根对象出发，**标记堆中所有对象**
- **最终标记阶段**：**并发标记漏标错标对象**，使用**STAB机制**实现，选出**回收价值最大的区域作为目标区域**等待回收
- **并发回收阶段**：待回收区域中的存活对象**复制到其他未使用的Region区**中去，然后会将**原本的Region区全部清理并回收**

#### 通过原本指针访问时如何定位对象

- **转发指针**（未移动的指向自己，移动的指向**BrooksPointers转发指针**）

#### 并发回收导致的线程

已经复制对象了，只是还**没来得及更新旧对象的转发指针**

- 读、写屏障确保（GC线程正在**复制旧对象去到新的区**；GC线程**将原本旧对象的转发指针指向新对象的转发指针**）

#### 如何解决跨区引用

- 类似于一个二维数组，有引用进行打标

# 面试-并发标记-CMS三色标记

## 标记过程

- 发生**短暂的STW**，将所有与GcRoots**直接相连的对象转入灰色集合**
- 并发执行**遍历黑色**，**全部标记可达性对象从白色后转为灰色集合**；**根对象转入黑色**
- **重复直到灰色没有**
- **再次STW**；屏障检测对象是否有变化，**纠正误标**
- **并发执行清除工作**，再把标记复位，所有的对象再次放入白色集合中

## 如何解决漏标问题

**写屏障+增量**

## 跨带引用

- **记录集**：记录从**非收集区到收集区的引用指针集合**
- **卡表**：中记录中**记忆集的记录精度**、与**堆内存区域的映射关系**

# 面试-GC日志

## YoungGC日志详解

GC类型+GC原因+GC收集器+新生代描述+堆空间描述+耗时描述

## FullGC日志详解

GC类型+GC原因+新生代描述+年老代描述+堆空间描述+元数据空间+耗时描述

## 诱发GC的原因

# 面试-程序监控及性能调优

## 进程监控-JPS

```
 #实时查看JVM的进程
 jps [pid]
```

## 配置信息查看工具-jinfo

```
 #实时查看JVM的运行参数
 jinfo -flags [pid]
```

## 信息统计工具-jstat

```
 jstat -gc -t -h30 9895 1s 300
 -gc：监控GC的状态
 -t：显示系统运行的时间
 -h30：间隔30行数据，输出一次表头
 9895：Java进程ID
 1s：时间间隔
 300：本次输出的数据行数
```

## 堆内存统计分析工具-jmap

```
 jmap -clstats [pid]
 jmap -dump:live,format=b,file=Dump.phrof [pid]等。
 #堆快照导出命令解析：
 live：导出堆中存活对象快照；
 format：指定输出格式；
 file：指定输出的文件名及其格式（.dat、.phrof等格式）
```

## 堆内存快照分析工具-jhat

```
 jhat HeapDump.dat
 #输入http://localhost:7000查看jhat分析后生成的结果
 #.按照包路径查看不同类的具体对象实例
 #.所有Roots节点的集合
 #.所有类的对象实例数量（包括了JVM自身的类）
 #.所有类的对象实例数量（除去了JVM自身的类）
 #.Java堆中实例对象的统计直方图
```

## 堆栈跟踪工具-jstack

```
 #生成线程快照
 jstack -l [pid]
```

# 面试-JVM线上故障大合集

## OOM

- 上线已经部署**获取Dump文件**，**调小堆空间“现场”重现**
- **接口压测**；主动式的**通过jmap等工具**导出堆的Dump文件
- **jvisualvm**，或**第三方的MAT**工具
- **确定溢出区域**
- **代码优化**

一般问题：（**大数据载入；使用容器未及时清理；循环；第三方依赖；内存泄漏；第三方大量加载**）

## JVM内存泄露

- **堆内泄漏**：由于**代码不合理**导致内存出现泄漏，如**垃圾对象与静态对象保持着引用、未正确的关闭外部连接**（DB连接、Socket连接、文件IO流）等。
- **堆外泄漏**：**申请buffer流后未释放内存、直接内存中的数据未手动清理**等

## 业务线程死锁

- JPS定位到具体的线程查看代码

## 应用程序异常宕机

- keepalived实现通知重启

## 响应速度变慢和线程出现阻塞

- **程序整体响应过慢**，从各个层面实时定位
- **单个接口响应缓慢**（sql和接口内部实现）

## CPU利用率居高不下

- **top指令**查看系统后台进程的资源占用情况
- top -Hp [pid]进一步排查Java程序中，**CPU占用率最高的线程**；将其**转换为16进制的值**
- jstack工具**导出Java应用的堆栈线程快照信息**
- 在**线程栈信息中搜索，定位导致CPU飙升的具体代码**（业务线程）
- **如果是VM线程**，那可能是由于频繁GC、频繁编译等JVM的操作导致

## 其他（待补充）

磁盘使用率100%、DNS劫持、数据库被勒索、木马病毒入侵、矿机脚本植入、网络故障等等

# 面试-JVM调优

## 优化思路

- **单个节点调优**（线程模型，CPU调度，内存回收，IO速率）
- **架构优化**（多级分布式缓存、缓存中间件做集群、消息中间件做集群、Java程序做集群、数据库做分库分表、搜索中间件做集群）
- **上线前预测**（预期流量压力；上线后完备的监控系统）
- **权衡利弊**（摒弃非核心功能）
- **性能调优**（定位瓶颈位置）

## 新生代-垃圾收集调优策略（G1之前）

> **少创建对象**、**多分配空间**，以减少GC次数，加大系统吞吐量

### 分配速率（多轮平均值）

> 通过 分配速率 和 回收速率的比较确定系统状态

**分配速率计算公式**：(本轮GC前使用容量-上轮GC后使用容量)/(本轮GC时间-上轮GC时间)

### 调优思路

- 新生代**分配更大的堆空间**；速率提高；**GC的阈值自然会增加**，从而能够达到减少GC频率的目的

## 年老代-垃圾收集调优策略（G1之前）

### 提升速率（多轮平均值）

**提升速率计算公式**：((新生代回收前使用总量-新生代回收后使用总量)-(整堆回收前使用总量-整堆回收后使用总量))/(本轮GC时间-上轮GC时间)【第一次不计算，刚才“冷状态启动”】

### 进入年老代的三种异常

- **内存泄漏**
- **频繁的大对象分配**
- **高并发/大流量压力**

### 调优思路

- **避免或尽量减少过早提升**（规模比较大的情况下，提升速率比较高也是合理的）

### 过早提升表现

- **一次FullGC**后，年老代的**空间占用比极速下降**
- **短时间内频繁**触发FullGC
- **提升速率接近分配速率**
- **新生代GC发生后，新生代的空间占用比下降到20%以内**

### 如何解决过早提升

- 业务或流量**压力变大**导致的，那么**增大新生代空间**
- 优化代码
- **短命的大对象分配**，如大数组，则可以考虑**优化数据结构**，如换成链表

## 合理堆空间分配

**计算活跃数据大小** = 多次GC后年老代中的对象

- 堆空间：活跃数据大小的`4~5`倍
- 新生代：活跃数据大小的`1.5~2`倍
- 年老代：活跃数据大小的`2.5~3`倍
- 元空间：活跃数据大小的`1.2~1.8`倍

**实际过程**：`-Xmx、-Xms`两个参数设定的值必须一致

## 建议监控的GC信息

- 流量方面：流量峰值、流量均值、用活时间段
- 对象方面：分配速率，提升速率
- GC方面：MinorGC、FullGC停顿时长、GC触发间隔、GC回收总量

# 面试-阿里在线排除工具

[(十一)JVM成神路之性能调优篇：GC调优、Arthas工具详解及各场景下线上最佳配置推荐 - 掘金](https://juejin.cn/post/7090425690595524615#heading-9)

## 应用范围

- 排查CPU**占用过高**
- **排查线程阻塞问题**
- **排查死锁问题**
- **排查方法执行过慢问题**
- **动态修改线上代码**

# 面试-不同场景下最佳配置

## 堆空间

- 对象存活较高的业务，Survivor区与Eden区比值建议为2:4，即-XX:SurvivorRatio=4。
- 对象晋升年龄阈值建议：
  - 对象存活率较低的业务：保留默认值，即15。
  - 对象存活率较高的业务：建议调小，如-XX:MaxTenuringThreshold=7，可以减少大量存活对象在幸存区反复横跳带来的性能开销。
- JIT编译的热点代码缓存区至少64M，即-XX:ReservedCodeCacheSize=64m。
- TLAB线程私有区域可以调整为Eden区的1/10，即-XX:TLABWasteTargetPercent=10。
- 记得打开OOM时Dump堆的参数，以及执行脚本可以指定为重启应用

#### 元空间

一般在“活跃数据”的1.2倍左右足够，如果程序内使用大量动态代理，可以尝试加大到1.5、1.8倍

#### 栈空间

单个进程中的线程数量一般最多控制3000~5000最佳

## GC垃圾收集

- **选择垃圾收集器**

  - 将堆空间调整到合适的大小后，优先让JVM自行根据配置选择。
  - 如果内存小于`100MB`或部署在单核/双核机器，使用串行收集器
  - JDK8及以前追求低延迟（响应速度）选`ParNew+CMS`，追求高吞吐则选`PS+PO`。
  - 后续新版本的JDK中，`8GB`以上可以考虑选用`G1`，上百`GB`规模可采用`ZGC`

- **ParNew+CMS组合参数推荐**

  使用`ParNew+CMS`组合：`-XX:+UseParNewGC -XX:+UseConcMarkSweepGC`。

  ①并行收集GC线程数建议为CPU核数，即`-XX:ParallelCMSThreads=CPU*core`。

  ②内存碎片整理方面（`MSC`工作）：

  - `-XX:+UseCMSCompactAtFullCollection`：内存碎片化严重时开启`MSC`整理。
  - 建议将每次`FullGC`后的内存整理改为`2-3`轮触发一次，即`-XX:CMSFullGCsBeforeCompaction`。

  ③因为是追求响应速度的组合，因此目标停顿时间可以适当偏小一些，即`-XX:MaxGCPauseMillis`。

  ④激进优化策略：

  - `-XX:+CMSParallellnitialMarkEnabled`：在初始阶段采用多线程执行。
  - `-XX:+CMSParallelRemarkEnabled`：在重新标记阶段采用多线程执行。
  - `-XX:+CMSScavengeBeforeRemark`：在重新标记阶段前触发一次新生代GC。

- **ParallelScavenge+ParallelOld组合参数推荐**

  使用`PS+PO`组合：`-XX:+UseParallelGC -XX:+UseParallelOldGC`。

  ①并行收集GC线程数建议为CPU核数，即`-XX:ParallelGCThreads=CPU*core`。

  ②因为是追求吞吐的组合，因此吞吐比尽量可以调高，即`-XX:GCTimeRatio`，如若无经验没法预估准确值，那则可以开启JVM的自适应调整策略：`-XX:+UseAdaptiveSizePolicy`

- **G1整堆收集器参数推荐**

  使用`G1`收集器：`-XX:+UseG1GC`。

  ①不要强制使用`-Xmn`参数设置年轻代的大小，因为G1是通过动态调整年轻代大小达到目标暂停时间的目的。

  ②如果分配的对象平均体积过大，可以适当调大每个分区的`Size`，但必须要为`2`的次幂，即通过`-XX:G1HeapRegionSize`调整，正常情况下尽量不要手动调整。

  ③尽量可以将并发线程数调整的大一些，即`-XX:ConcGCThreads`，一般推荐为CPU核数`+1~2`。

  ④手动指定触发混合GC的阈值，关闭`IHOP`适应分析，消除自适应计算的耗时，`-XX:InitiatingHeapOccupancyPercent=45 -XX:-G1UseAdaptiveIHOP`。

  ⑤混合GC时间过长可微调该三个参数：`-XX:G1MixedGCCountTarget=8 -XX:G1MixedGCLiveThresholdPercent=88 -XX:G1HeapWastePercent=5`

- **激进优化的策略**

  ①`-XX:ParGCCardsPerStrideChunk=4096`：CMS激进优化策略，增大GC线程扫描卡表的范围，默认为`256`，三个最佳值为`32768、4K、8K`。

  ②`-XX:+AlwaysPreTouch`：开启物理内存分配替换虚拟内存分配，优化分配率。

  ③`-XX:+UseLargePages`：启用内存大页面分配技术。

  ④`-XX:-UseBiasedLocking`：关闭偏向锁，在并发较高的系统中关闭反而可以提升性能。

  ⑤`-XX:AutoBoxCacheMax=20000`：加大`IntrgerCache`的缓存。

  ⑥`-XX:-UseCounterDecay`：关闭JIT即时编译器的热度衰减机制（会消耗一定内存）。

  ⑦`-XX:-TieredCompilation`：关闭`C1`静态编译器编译，直接使用`C2`编译。

  ⑧`-XX:MaxDirectMemorySize`：直接内存大小如果确认用的比较少，可以调小，如果用的比较多，可以适当调大