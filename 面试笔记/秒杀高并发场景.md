#  秒杀系统设计

## 涉及到的细节

- 瞬时高并发
- 页面静态化
- 秒杀按钮
- 读多写少
- 缓存问题
- 库存问题
- 分布式锁
- mq异步处理
- 如何限流

### 页面静态化

CDN 使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率

### 秒杀按钮

- 秒杀开始之前，js标志为false，还有另外一个随机参数
- 秒杀开始；系统会生成一个标志为true的新的js文件，随机参数生成一个新值，然后同步给CDN
- 前端加定时器，时间限制内不允许再次点击

### 读多写少

- 部署多个节点的 redis 缓存（保存库存等基础信息）



![img](秒杀高并发场景.assets/7decb7ff30dbac536a3cf86d72e37df8.jpeg)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

#### 造成的问题

##### 缓存击穿

> 大规模的key失效，而缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上

###### 解决方案

- 缓存预热（解决大量数据刚开始直接打到数据库的问题）
- 热点的key可以设置永不过期的key；本场景涉及库存变化，所以不适用
- 使用分布式锁（解决同一时刻拿同一个商品的库存只有一个线程可以拿到）

##### 缓存穿透

大量的请求传入的商品id，在缓存中和数据库中都不存在

解决方案

- 布隆过滤器
  - 解决大量的请求传入的商品id不存在时；直接到数据库的问题（适用于缓存数据更新很少的场景）
  - 同步失败，需要增加重试机制，跨数据源，不能保证数据实时一致性吗
- 把不存在的商品id也缓存起来，设置的超时时间尽量短

##### 缓存雪崩

- 在原有的失效时间上加上一个随机值
- 熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示；使用 redis 的LUA 脚本做限流

### 库存问题

> 如果用户在一段时间内，还没完成支付，扣减的库存是要加回去的

#### 预扣库存



![img](秒杀高并发场景.assets/f696e15cafb40afd446d4932b00d8c72.jpeg)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

##### 基于数据库乐观锁

> synchronized 性能不好

```
update product set stock=stock-1 where id=product and stock > 0;
```

##### redis LUA 脚本扣减库存

- 先判断商品id是否存在，如果不存在则直接返回。
- 获取该商品id的库存，判断库存如果是-1，则直接返回，表示不限制库存。
- 如果库存大于0，则扣减库存。
- 如果库存等于0，是直接返回，表示库存不足

### 分布式锁

> 大量的请求都去查一个缓存中不存在的商品

#### 手动

```
jedis.set(lockKey, requestId, "NX", "PX", expireTime);
```

要用requestId，或者唯一标识的id，在释放锁的时候，只能释放自己加的锁

#### 使用 lua 脚本

#### 均匀分布的秒杀

> 1万个请求，有1个成功。再1万个请求，有1个成功（成功取决的）

在规定的时间，比如500毫秒内，自旋不断尝试加锁，如果成功则直接返回。如果失败，则休眠50毫秒，再发起新一轮的尝试

### mq异步处理

> 真正并发量大的是秒杀功能，下单和支付功能实际并发量很小

#### 消息丢失问题

##### 加消息发送表



![img](秒杀高并发场景.assets/ee12335d002fdfca836eda1b61385869.jpeg)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

##### job增加重试机制

job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息

#### 重复消费问题

##### 加消息处理表



![img](秒杀高并发场景.assets/817d8569a461d08d0ab17b529935a729.jpeg)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

**下单和写消息处理表，要放在同一个事务中，保证原子操作**

#### 垃圾消息问题

job重试时,判断一下消息发送表中该消息的发送次数是否达到最大限制,达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息

#### 延迟消费问题

> 如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存

下单时消息生产者会先生成订单，此时状态为待支付,然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。

**用户完成支付之后，会修改订单状态为已支付**

### 如何限流

#### 基于nginx限流

#### 基于redis限流

- 对同一用户限流

  限制同一个用户id，比如每分钟只能请求5次接口

- 对同一ip限流

  限制同一个ip，比如每分钟只能请求5次接口

  可能会有误杀的情况(同一个公司或网吧的出口ip是相同的)

- 对接口限流

- 加验证码

###### 三种不同操作

- setnx的操作

  在10秒内限定20个请求，那么我们在setnx的时候可以设置过期时间10，当请求的setnx数量达到20时候即达到了限流效果

  缺点就是无法统计2-11秒 3-13 秒

- 基于 zset 滑动窗口

  zset数据结构也提供了range方法让我们可以很轻易的获取到2个时间戳内有多少请求

  缺点就是zset的数据结构会越来越大

- 基于Redis的令牌桶算法



![img](秒杀高并发场景.assets/format,png.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

结合Redis的List数据结构；leftPop获取令牌；定时rightPush令牌（判断令牌桶是否满了，或者设置令牌失效时间）